<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Collections and Data Structures · The Julia Language</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/julia-manual.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar">
    <p style="text-align: center;">JuliaMono edition</p>
<a class="docs-logo" href="../index.html"><img class="docs-light-only" src="../assets/logo.svg" alt="The Julia Language logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="The Julia Language logo"/></a><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/getting-started.html">Getting Started</a></li><li><a class="tocitem" href="../manual/variables.html">Variables</a></li><li><a class="tocitem" href="../manual/integers-and-floating-point-numbers.html">Integers and Floating-Point Numbers</a></li><li><a class="tocitem" href="../manual/mathematical-operations.html">Mathematical Operations and Elementary Functions</a></li><li><a class="tocitem" href="../manual/complex-and-rational-numbers.html">Complex and Rational Numbers</a></li><li><a class="tocitem" href="../manual/strings.html">Strings</a></li><li><a class="tocitem" href="../manual/functions.html">Functions</a></li><li><a class="tocitem" href="../manual/control-flow.html">Control Flow</a></li><li><a class="tocitem" href="../manual/variables-and-scoping.html">Scope of Variables</a></li><li><a class="tocitem" href="../manual/types.html">Types</a></li><li><a class="tocitem" href="../manual/methods.html">Methods</a></li><li><a class="tocitem" href="../manual/constructors.html">Constructors</a></li><li><a class="tocitem" href="../manual/conversion-and-promotion.html">Conversion and Promotion</a></li><li><a class="tocitem" href="../manual/interfaces.html">Interfaces</a></li><li><a class="tocitem" href="../manual/modules.html">Modules</a></li><li><a class="tocitem" href="../manual/documentation.html">Documentation</a></li><li><a class="tocitem" href="../manual/metaprogramming.html">Metaprogramming</a></li><li><a class="tocitem" href="../manual/arrays.html">Multi-dimensional Arrays</a></li><li><a class="tocitem" href="../manual/missing.html">Missing Values</a></li><li><a class="tocitem" href="../manual/networking-and-streams.html">Networking and Streams</a></li><li><a class="tocitem" href="../manual/parallel-computing.html">Parallel Computing</a></li><li><a class="tocitem" href="../manual/running-external-programs.html">Running External Programs</a></li><li><a class="tocitem" href="../manual/calling-c-and-fortran-code.html">Calling C and Fortran Code</a></li><li><a class="tocitem" href="../manual/handling-operating-system-variation.html">Handling Operating System Variation</a></li><li><a class="tocitem" href="../manual/environment-variables.html">Environment Variables</a></li><li><a class="tocitem" href="../manual/embedding.html">Embedding Julia</a></li><li><a class="tocitem" href="../manual/code-loading.html">Code Loading</a></li><li><a class="tocitem" href="../manual/profile.html">Profiling</a></li><li><a class="tocitem" href="../manual/stacktraces.html">Stack Traces</a></li><li><a class="tocitem" href="../manual/performance-tips.html">Performance Tips</a></li><li><a class="tocitem" href="../manual/workflow-tips.html">Workflow Tips</a></li><li><a class="tocitem" href="../manual/style-guide.html">Style Guide</a></li><li><a class="tocitem" href="../manual/faq.html">Frequently Asked Questions</a></li><li><a class="tocitem" href="../manual/noteworthy-differences.html">Noteworthy Differences from other Languages</a></li><li><a class="tocitem" href="../manual/unicode-input.html">Unicode Input</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Base</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="base.html">Essentials</a></li><li class="is-active"><a class="tocitem" href="collections.html">Collections and Data Structures</a><ul class="internal"><li><a class="tocitem" href="#lib-collections-iteration-1"><span>Iteration</span></a></li><li><a class="tocitem" href="#Constructors-and-Types-1"><span>Constructors and Types</span></a></li><li><a class="tocitem" href="#General-Collections-1"><span>General Collections</span></a></li><li><a class="tocitem" href="#Iterable-Collections-1"><span>Iterable Collections</span></a></li><li><a class="tocitem" href="#Indexable-Collections-1"><span>Indexable Collections</span></a></li><li><a class="tocitem" href="#Dictionaries-1"><span>Dictionaries</span></a></li><li><a class="tocitem" href="#Set-Like-Collections-1"><span>Set-Like Collections</span></a></li><li><a class="tocitem" href="#Dequeues-1"><span>Dequeues</span></a></li><li><a class="tocitem" href="#Utility-Collections-1"><span>Utility Collections</span></a></li></ul></li><li><a class="tocitem" href="math.html">Mathematics</a></li><li><a class="tocitem" href="numbers.html">Numbers</a></li><li><a class="tocitem" href="strings.html">Strings</a></li><li><a class="tocitem" href="arrays.html">Arrays</a></li><li><a class="tocitem" href="parallel.html">Tasks</a></li><li><a class="tocitem" href="multi-threading.html">Multi-Threading</a></li><li><a class="tocitem" href="constants.html">Constants</a></li><li><a class="tocitem" href="file.html">Filesystem</a></li><li><a class="tocitem" href="io-network.html">I/O and Network</a></li><li><a class="tocitem" href="punctuation.html">Punctuation</a></li><li><a class="tocitem" href="sort.html">Sorting and Related Functions</a></li><li><a class="tocitem" href="iterators.html">Iteration utilities</a></li><li><a class="tocitem" href="c.html">C Interface</a></li><li><a class="tocitem" href="libc.html">C Standard Library</a></li><li><a class="tocitem" href="stacktraces.html">StackTraces</a></li><li><a class="tocitem" href="simd-types.html">SIMD Support</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Standard Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../stdlib/Base64.html">Base64</a></li><li><a class="tocitem" href="../stdlib/CRC32c.html">CRC32c</a></li><li><a class="tocitem" href="../stdlib/Dates.html">Dates</a></li><li><a class="tocitem" href="../stdlib/DelimitedFiles.html">Delimited Files</a></li><li><a class="tocitem" href="../stdlib/Distributed.html">Distributed Computing</a></li><li><a class="tocitem" href="../stdlib/FileWatching.html">File Events</a></li><li><a class="tocitem" href="../stdlib/Future.html">Future</a></li><li><a class="tocitem" href="../stdlib/InteractiveUtils.html">Interactive Utilities</a></li><li><a class="tocitem" href="../stdlib/LibGit2.html">LibGit2</a></li><li><a class="tocitem" href="../stdlib/Libdl.html">Dynamic Linker</a></li><li><a class="tocitem" href="../stdlib/LinearAlgebra.html">Linear Algebra</a></li><li><a class="tocitem" href="../stdlib/Logging.html">Logging</a></li><li><a class="tocitem" href="../stdlib/Markdown.html">Markdown</a></li><li><a class="tocitem" href="../stdlib/Mmap.html">Memory-mapped I/O</a></li><li><a class="tocitem" href="../stdlib/Pkg.html">Pkg</a></li><li><a class="tocitem" href="../stdlib/Printf.html">Printf</a></li><li><a class="tocitem" href="../stdlib/Profile.html">Profiling</a></li><li><a class="tocitem" href="../stdlib/REPL.html">The Julia REPL</a></li><li><a class="tocitem" href="../stdlib/Random.html">Random Numbers</a></li><li><a class="tocitem" href="../stdlib/SHA.html">SHA</a></li><li><a class="tocitem" href="../stdlib/Serialization.html">Serialization</a></li><li><a class="tocitem" href="../stdlib/SharedArrays.html">Shared Arrays</a></li><li><a class="tocitem" href="../stdlib/Sockets.html">Sockets</a></li><li><a class="tocitem" href="../stdlib/SparseArrays.html">Sparse Arrays</a></li><li><a class="tocitem" href="../stdlib/Statistics.html">Statistics</a></li><li><a class="tocitem" href="../stdlib/Test.html">Unit Testing</a></li><li><a class="tocitem" href="../stdlib/UUIDs.html">UUIDs</a></li><li><a class="tocitem" href="../stdlib/Unicode.html">Unicode</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/reflection.html">Reflection and introspection</a></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Documentation of Julia&#39;s Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/init.html">Initialization of the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/ast.html">Julia ASTs</a></li><li><a class="tocitem" href="../devdocs/types.html">More about types</a></li><li><a class="tocitem" href="../devdocs/object.html">Memory layout of Julia Objects</a></li><li><a class="tocitem" href="../devdocs/eval.html">Eval of Julia code</a></li><li><a class="tocitem" href="../devdocs/callconv.html">Calling Conventions</a></li><li><a class="tocitem" href="../devdocs/compiler.html">High-level Overview of the Native-Code Generation Process</a></li><li><a class="tocitem" href="../devdocs/functions.html">Julia Functions</a></li><li><a class="tocitem" href="../devdocs/cartesian.html">Base.Cartesian</a></li><li><a class="tocitem" href="../devdocs/meta.html">Talking to the compiler (the <code>:meta</code> mechanism)</a></li><li><a class="tocitem" href="../devdocs/subarrays.html">SubArrays</a></li><li><a class="tocitem" href="../devdocs/isbitsunionarrays.html">isbits Union Optimizations</a></li><li><a class="tocitem" href="../devdocs/sysimg.html">System Image Building</a></li><li><a class="tocitem" href="../devdocs/llvm.html">Working with LLVM</a></li><li><a class="tocitem" href="../devdocs/stdio.html">printf() and stdio in the Julia runtime</a></li><li><a class="tocitem" href="../devdocs/boundscheck.html">Bounds checking</a></li><li><a class="tocitem" href="../devdocs/locks.html">Proper maintenance and care of multi-threading locks</a></li><li><a class="tocitem" href="../devdocs/offset-arrays.html">Arrays with custom indices</a></li><li><a class="tocitem" href="../devdocs/require.html">Module loading</a></li><li><a class="tocitem" href="../devdocs/inference.html">Inference</a></li><li><a class="tocitem" href="../devdocs/ssair.html">Julia SSA-form IR</a></li><li><a class="tocitem" href="../devdocs/gc-sa.html">Static analyzer annotations for GC correctness in C code</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">Developing/debugging Julia&#39;s C code</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../devdocs/backtraces.html">Reporting and analyzing crashes (segfaults)</a></li><li><a class="tocitem" href="../devdocs/debuggingtips.html">gdb debugging tips</a></li><li><a class="tocitem" href="../devdocs/valgrind.html">Using Valgrind with Julia</a></li><li><a class="tocitem" href="../devdocs/sanitizers.html">Sanitizer support</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Base</a></li><li class="is-active"><a href="collections.html">Collections and Data Structures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="collections.html">Collections and Data Structures</a></li></ul></nav>

<div class="docs-right">
<span style="text-align:center; font-face: JuliaMono-Regular";>JuliaMono edition</span>





<a class="docs-edit-link"
 href="https://github.com/JuliaLang/julia/blob/master/doc/src/base/collections.md" title="Edit on GitHub"><span class="docs-icon fab"> </span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Collections-and-Data-Structures-1"><a class="docs-heading-anchor" href="#Collections-and-Data-Structures-1">Collections and Data Structures</a><a class="docs-heading-anchor-permalink" href="#Collections-and-Data-Structures-1" title="Permalink"></a></h1><h2 id="lib-collections-iteration-1"><a class="docs-heading-anchor" href="#lib-collections-iteration-1">Iteration</a><a class="docs-heading-anchor-permalink" href="#lib-collections-iteration-1" title="Permalink"></a></h2><p>Sequential iteration is implemented by the <a href="collections.html#Base.iterate"><code>iterate</code></a> function. The general <code>for</code> loop:</p><pre><code class="language-julia">for i in iter   # or  &quot;for i = iter&quot;
    # body
end</code></pre><p>is translated into:</p><pre><code class="language-julia">next = iterate(iter)
while next !== nothing
    (i, state) = next
    # body
    next = iterate(iter, state)
end</code></pre><p>The <code>state</code> object may be anything, and should be chosen appropriately for each iterable type. See the <a href="../manual/interfaces.html#man-interface-iteration-1">manual section on the iteration interface</a> for more details about defining a custom iterable type.</p><article class="docstring"><header><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iterate(iter [, state]) -&gt; Union{Nothing, Tuple{Any, Any}}</code></pre><p>Advance the iterator to obtain the next element. If no elements remain, <code>nothing</code> should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/essentials.jl#L823-L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IteratorSize" href="#Base.IteratorSize"><code>Base.IteratorSize</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IteratorSize(itertype::Type) -&gt; IteratorSize</code></pre><p>Given the type of an iterator, return one of the following values:</p><ul><li><code>SizeUnknown()</code> if the length (number of elements) cannot be determined in advance.</li><li><code>HasLength()</code> if there is a fixed, finite length.</li><li><code>HasShape{N}()</code> if there is a known length plus a notion of multidimensional shape (as for an array).  In this case <code>N</code> should give the number of dimensions, and the <a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a> function is valid  for the iterator.</li><li><code>IsInfinite()</code> if the iterator yields values forever.</li></ul><p>The default value (for iterators that do not define this function) is <code>HasLength()</code>. This means that most iterators are assumed to implement <a href="collections.html#Base.length"><code>length</code></a>.</p><p>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</p><pre><code class="language-julia-repl">julia&gt; Base.IteratorSize(1:5)
Base.HasShape{1}()

julia&gt; Base.IteratorSize((2,3))
Base.HasLength()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/generator.jl#L64-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IteratorEltype" href="#Base.IteratorEltype"><code>Base.IteratorEltype</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IteratorEltype(itertype::Type) -&gt; IteratorEltype</code></pre><p>Given the type of an iterator, return one of the following values:</p><ul><li><code>EltypeUnknown()</code> if the type of elements yielded by the iterator is not known in advance.</li><li><code>HasEltype()</code> if the element type is known, and <a href="collections.html#Base.eltype"><code>eltype</code></a> would return a meaningful value.</li></ul><p><code>HasEltype()</code> is the default, since iterators are assumed to implement <a href="collections.html#Base.eltype"><code>eltype</code></a>.</p><p>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</p><pre><code class="language-julia-repl">julia&gt; Base.IteratorEltype(1:5)
Base.HasEltype()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/generator.jl#L104-L122">source</a></section></article><p>Fully implemented by:</p><ul><li><a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a></li><li><a href="collections.html#Base.UnitRange"><code>UnitRange</code></a></li><li><code>Tuple</code></li><li><code>Number</code></li><li><a href="arrays.html#Core.AbstractArray"><code>AbstractArray</code></a></li><li><a href="collections.html#Base.BitSet"><code>BitSet</code></a></li><li><a href="collections.html#Base.IdDict"><code>IdDict</code></a></li><li><a href="collections.html#Base.Dict"><code>Dict</code></a></li><li><a href="collections.html#Base.WeakKeyDict"><code>WeakKeyDict</code></a></li><li><code>EachLine</code></li><li><code>AbstractString</code></li><li><a href="collections.html#Base.Set"><code>Set</code></a></li><li><a href="collections.html#Base.Pair"><code>Pair</code></a></li><li><a href="base.html#Core.NamedTuple"><code>NamedTuple</code></a></li></ul><h2 id="Constructors-and-Types-1"><a class="docs-heading-anchor" href="#Constructors-and-Types-1">Constructors and Types</a><a class="docs-heading-anchor-permalink" href="#Constructors-and-Types-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractRange" href="#Base.AbstractRange"><code>Base.AbstractRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractRange{T}</code></pre><p>Supertype for ranges with elements of type <code>T</code>. <a href="collections.html#Base.UnitRange"><code>UnitRange</code></a> and other types are subtypes of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/range.jl#L134-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.OrdinalRange" href="#Base.OrdinalRange"><code>Base.OrdinalRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OrdinalRange{T, S} &lt;: AbstractRange{T}</code></pre><p>Supertype for ordinal ranges with elements of type <code>T</code> with spacing(s) of type <code>S</code>. The steps should be always-exact multiples of <a href="numbers.html#Base.oneunit"><code>oneunit</code></a>, and <code>T</code> should be a &quot;discrete&quot; type, which cannot have values smaller than <code>oneunit</code>. For example, <code>Integer</code> or <code>Date</code> types would qualify, whereas <code>Float64</code> would not (since this type can represent values smaller than <code>oneunit(Float64)</code>. <a href="collections.html#Base.UnitRange"><code>UnitRange</code></a>, <a href="collections.html#Base.StepRange"><code>StepRange</code></a>, and other types are subtypes of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/range.jl#L149-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractUnitRange" href="#Base.AbstractUnitRange"><code>Base.AbstractUnitRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractUnitRange{T} &lt;: OrdinalRange{T, T}</code></pre><p>Supertype for ranges with a step size of <a href="numbers.html#Base.oneunit"><code>oneunit(T)</code></a> with elements of type <code>T</code>. <a href="collections.html#Base.UnitRange"><code>UnitRange</code></a> and other types are subtypes of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/range.jl#L162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.StepRange" href="#Base.StepRange"><code>Base.StepRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StepRange{T, S} &lt;: OrdinalRange{T, S}</code></pre><p>Ranges with elements of type <code>T</code> with spacing of type <code>S</code>. The step between each element is constant, and the range is defined in terms of a <code>start</code> and <code>stop</code> of type <code>T</code> and a <code>step</code> of type <code>S</code>. Neither <code>T</code> nor <code>S</code> should be floating point types. The syntax <code>a:b:c</code> with <code>b &gt; 1</code> and <code>a</code>, <code>b</code>, and <code>c</code> all integers creates a <code>StepRange</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; collect(StepRange(1, Int8(2), 10))
5-element Array{Int64,1}:
 1
 3
 5
 7
 9

julia&gt; typeof(StepRange(1, Int8(2), 10))
StepRange{Int64,Int8}

julia&gt; typeof(1:3:6)
StepRange{Int64,Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/range.jl#L170-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.UnitRange" href="#Base.UnitRange"><code>Base.UnitRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UnitRange{T&lt;:Real}</code></pre><p>A range parameterized by a <code>start</code> and <code>stop</code> of type <code>T</code>, filled with elements spaced by <code>1</code> from <code>start</code> until <code>stop</code> is exceeded. The syntax <code>a:b</code> with <code>a</code> and <code>b</code> both <code>Integer</code>s creates a <code>UnitRange</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; collect(UnitRange(2.3, 5.2))
3-element Array{Float64,1}:
 2.3
 3.3
 4.3

julia&gt; typeof(1:10)
UnitRange{Int64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/range.jl#L255-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.LinRange" href="#Base.LinRange"><code>Base.LinRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinRange{T}</code></pre><p>A range with <code>len</code> linearly spaced elements between its <code>start</code> and <code>stop</code>. The size of the spacing is controlled by <code>len</code>, which must be an <code>Int</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; LinRange(1.5, 5.5, 9)
9-element LinRange{Float64}:
 1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/range.jl#L357-L370">source</a></section></article><h2 id="General-Collections-1"><a class="docs-heading-anchor" href="#General-Collections-1">General Collections</a><a class="docs-heading-anchor-permalink" href="#General-Collections-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.isempty" href="#Base.isempty"><code>Base.isempty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isempty(collection) -&gt; Bool</code></pre><p>Determine whether a collection is empty (has no elements).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; isempty([])
true

julia&gt; isempty([1 2 3])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/essentials.jl#L722-L735">source</a></section><section><div><pre><code class="language-none">isempty(condition)</code></pre><p>Return <code>true</code> if no tasks are waiting on the condition, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/condition.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.empty!" href="#Base.empty!"><code>Base.empty!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">empty!(collection) -&gt; collection</code></pre><p>Remove all elements from a <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Dict(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)
Dict{String,Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; empty!(A);

julia&gt; A
Dict{String,Int64} with 0 entries</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L245-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">length(collection) -&gt; Integer</code></pre><p>Return the number of elements in the collection.</p><p>Use <a href="collections.html#Base.lastindex"><code>lastindex</code></a> to get the last valid index of an indexable collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; length(1:5)
5

julia&gt; length([1, 2, 3, 4])
4

julia&gt; length([1 2; 3 4])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractarray.jl#L171-L189">source</a></section></article><p>Fully implemented by:</p><ul><li><a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a></li><li><a href="collections.html#Base.UnitRange"><code>UnitRange</code></a></li><li><code>Tuple</code></li><li><code>Number</code></li><li><a href="arrays.html#Core.AbstractArray"><code>AbstractArray</code></a></li><li><a href="collections.html#Base.BitSet"><code>BitSet</code></a></li><li><a href="collections.html#Base.IdDict"><code>IdDict</code></a></li><li><a href="collections.html#Base.Dict"><code>Dict</code></a></li><li><a href="collections.html#Base.WeakKeyDict"><code>WeakKeyDict</code></a></li><li><code>AbstractString</code></li><li><a href="collections.html#Base.Set"><code>Set</code></a></li><li><a href="base.html#Core.NamedTuple"><code>NamedTuple</code></a></li></ul><h2 id="Iterable-Collections-1"><a class="docs-heading-anchor" href="#Iterable-Collections-1">Iterable Collections</a><a class="docs-heading-anchor-permalink" href="#Iterable-Collections-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.in" href="#Base.in"><code>Base.in</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">in(item, collection) -&gt; Bool
∈(item, collection) -&gt; Bool
∋(collection, item) -&gt; Bool</code></pre><p>Determine whether an item is in the given collection, in the sense that it is <a href="math.html#Base.:=="><code>==</code></a> to one of the values generated by iterating over the collection. Returns a <code>Bool</code> value, except if <code>item</code> is <a href="base.html#Base.missing"><code>missing</code></a> or <code>collection</code> contains <code>missing</code> but not <code>item</code>, in which case <code>missing</code> is returned (<a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>, matching the behavior of <a href="collections.html#Base.any-Tuple{Any}"><code>any</code></a> and <a href="math.html#Base.:=="><code>==</code></a>).</p><p>Some collections follow a slightly different definition. For example, <a href="collections.html#Base.Set"><code>Set</code></a>s check whether the item <a href="base.html#Base.isequal"><code>isequal</code></a> to one of the elements. <a href="collections.html#Base.Dict"><code>Dict</code></a>s look for <code>key=&gt;value</code> pairs, and the key is compared using <a href="base.html#Base.isequal"><code>isequal</code></a>. To test for the presence of a key in a dictionary, use <a href="collections.html#Base.haskey"><code>haskey</code></a> or <code>k in keys(dict)</code>. For these collections, the result is always a <code>Bool</code> and never <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = 1:3:20
1:3:19

julia&gt; 4 in a
true

julia&gt; 5 in a
false

julia&gt; missing in [1, 2]
missing

julia&gt; 1 in [2, missing]
missing

julia&gt; 1 in [1, missing]
true

julia&gt; missing in Set([1, 2])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/operators.jl#L1057-L1099">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:∉" href="#Base.:∉"><code>Base.:∉</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">∉(item, collection) -&gt; Bool
∌(collection, item) -&gt; Bool</code></pre><p>Negation of <code>∈</code> and <code>∋</code>, i.e. checks that <code>item</code> is not in <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; 1 ∉ 2:4
true

julia&gt; 1 ∉ 1:3
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/operators.jl#L1102-L1116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype" href="#Base.eltype"><code>Base.eltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eltype(type)</code></pre><p>Determine the type of the elements generated by iterating a collection of the given <code>type</code>. For dictionary types, this will be a <code>Pair{KeyType,ValType}</code>. The definition <code>eltype(x) = eltype(typeof(x))</code> is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; eltype(fill(1f0, (2,2)))
Float32

julia&gt; eltype(fill(0x1, (2,2)))
UInt8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L105-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.indexin" href="#Base.indexin"><code>Base.indexin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">indexin(a, b)</code></pre><p>Return an array containing the first index in <code>b</code> for each value in <code>a</code> that is a member of <code>b</code>. The output array contains <code>nothing</code> wherever <code>a</code> is not a member of <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;b&#39;, &#39;d&#39;, &#39;a&#39;];

julia&gt; b = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];

julia&gt; indexin(a, b)
6-element Array{Union{Nothing, Int64},1}:
 1
 2
 3
 2
  nothing
 1

julia&gt; indexin(b, a)
3-element Array{Union{Nothing, Int64},1}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L2219-L2247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique" href="#Base.unique"><code>Base.unique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unique(itr)</code></pre><p>Return an array containing only the unique elements of collection <code>itr</code>, as determined by <a href="base.html#Base.isequal"><code>isequal</code></a>, in the order that the first of each set of equivalent elements originally appears. The element type of the input is preserved.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; unique([1, 2, 6, 2])
3-element Array{Int64,1}:
 1
 2
 6

julia&gt; unique(Real[1, 1.0, 2])
2-element Array{Real,1}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/set.jl#L90-L111">source</a></section><section><div><pre><code class="language-none">unique(f, itr)</code></pre><p>Returns an array containing one value from <code>itr</code> for each unique value produced by <code>f</code> applied to elements of <code>itr</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; unique(x -&gt; x^2, [1, -1, 3, -3, 4])
3-element Array{Int64,1}:
 1
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/set.jl#L153-L167">source</a></section><section><div><pre><code class="language-none">unique(A::AbstractArray; dims::Int)</code></pre><p>Return unique regions of <code>A</code> along dimension <code>dims</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = map(isodd, reshape(Vector(1:8), (2,2,2)))
2×2×2 Array{Bool,3}:
[:, :, 1] =
 1  1
 0  0

[:, :, 2] =
 1  1
 0  0

julia&gt; unique(A)
2-element Array{Bool,1}:
 1
 0

julia&gt; unique(A, dims=2)
2×1×2 Array{Bool,3}:
[:, :, 1] =
 1
 0

[:, :, 2] =
 1
 0

julia&gt; unique(A, dims=3)
2×2×1 Array{Bool,3}:
[:, :, 1] =
 1  1
 0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/multidimensional.jl#L1449-L1487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.unique!" href="#Base.unique!"><code>Base.unique!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unique!(f, A::AbstractVector)</code></pre><p>Selects one value from <code>A</code> for each unique value produced by <code>f</code> applied to elements of <code>A</code> , then return the modified A.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>This method is available as of Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; unique!(x -&gt; x^2, [1, -1, 3, -3, 4])
3-element Array{Int64,1}:
 1
 3
 4

julia&gt; unique!(n -&gt; n%3, [5, 1, 8, 9, 3, 4, 10, 7, 2, 6])
3-element Array{Int64,1}:
 5
 1
 9

julia&gt; unique!(iseven, [2, 3, 5, 7, 9])
2-element Array{Int64,1}:
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/set.jl#L205-L233">source</a></section><section><div><pre><code class="language-none">unique!(A::AbstractVector)</code></pre><p>Remove duplicate items as determined by <a href="base.html#Base.isequal"><code>isequal</code></a>, then return the modified <code>A</code>. <code>unique!</code> will return the elements of <code>A</code> in the order that they occur. If you do not care about the order of the returned data, then calling <code>(sort!(A); unique!(A))</code> will be much more efficient as long as the elements of <code>A</code> can be sorted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; unique!([1, 1, 1])
1-element Array{Int64,1}:
 1

julia&gt; A = [7, 3, 2, 3, 7, 5];

julia&gt; unique!(A)
4-element Array{Int64,1}:
 7
 3
 2
 5

julia&gt; B = [7, 6, 42, 6, 7, 42];

julia&gt; sort!(B);  # unique! is able to process sorted data much more efficiently.

julia&gt; unique!(B)
3-element Array{Int64,1}:
  6
  7
 42</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/set.jl#L293-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.allunique" href="#Base.allunique"><code>Base.allunique</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allunique(itr) -&gt; Bool</code></pre><p>Return <code>true</code> if all values from <code>itr</code> are distinct when compared with <a href="base.html#Base.isequal"><code>isequal</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [1; 2; 3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; allunique([a, a])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/set.jl#L347-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reduce-Tuple{Any,Any}" href="#Base.reduce-Tuple{Any,Any}"><code>Base.reduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reduce(op, itr; [init])</code></pre><p>Reduce the given collection <code>itr</code> with the given binary operator <code>op</code>. If provided, the initial value <code>init</code> must be a neutral element for <code>op</code> that will be returned for empty collections. It is unspecified whether <code>init</code> is used for non-empty collections.</p><p>For empty collections, providing <code>init</code> will be necessary, except for some special cases (e.g. when <code>op</code> is one of <code>+</code>, <code>*</code>, <code>max</code>, <code>min</code>, <code>&amp;</code>, <code>|</code>) when Julia can determine the neutral element of <code>op</code>.</p><p>Reductions for certain commonly-used operators may have special implementations, and should be used instead: <code>maximum(itr)</code>, <code>minimum(itr)</code>, <code>sum(itr)</code>, <code>prod(itr)</code>,  <code>any(itr)</code>, <code>all(itr)</code>.</p><p>The associativity of the reduction is implementation dependent. This means that you can&#39;t use non-associative operations like <code>-</code> because it is undefined whether <code>reduce(-,[1,2,3])</code> should be evaluated as <code>(1-2)-3</code> or <code>1-(2-3)</code>. Use <a href="collections.html#Base.foldl-Tuple{Any,Any}"><code>foldl</code></a> or <a href="collections.html#Base.foldr-Tuple{Any,Any}"><code>foldr</code></a> instead for guaranteed left or right associativity.</p><p>Some operations accumulate error. Parallelism will be easier if the reduction can be executed in groups. Future versions of Julia might change the algorithm. Note that the elements are not reordered if you use an ordered collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; reduce(*, [2; 3; 4])
24

julia&gt; reduce(*, [2; 3; 4]; init=-1)
-24</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L415-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.foldl-Tuple{Any,Any}" href="#Base.foldl-Tuple{Any,Any}"><code>Base.foldl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">foldl(op, itr; [init])</code></pre><p>Like <a href="collections.html#Base.reduce-Tuple{Any,Any}"><code>reduce</code></a>, but with guaranteed left associativity. If provided, the keyword argument <code>init</code> will be used exactly once. In general, it will be necessary to provide <code>init</code> to work with empty collections.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; foldl(=&gt;, 1:4)
((1 =&gt; 2) =&gt; 3) =&gt; 4

julia&gt; foldl(=&gt;, 1:4; init=0)
(((0 =&gt; 1) =&gt; 2) =&gt; 3) =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L159-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.foldr-Tuple{Any,Any}" href="#Base.foldr-Tuple{Any,Any}"><code>Base.foldr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">foldr(op, itr; [init])</code></pre><p>Like <a href="collections.html#Base.reduce-Tuple{Any,Any}"><code>reduce</code></a>, but with guaranteed right associativity. If provided, the keyword argument <code>init</code> will be used exactly once. In general, it will be necessary to provide <code>init</code> to work with empty collections.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; foldr(=&gt;, 1:4)
1 =&gt; (2 =&gt; (3 =&gt; 4))

julia&gt; foldr(=&gt;, 1:4; init=0)
1 =&gt; (2 =&gt; (3 =&gt; (4 =&gt; 0)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L203-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.maximum" href="#Base.maximum"><code>Base.maximum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maximum(f, itr)</code></pre><p>Returns the largest result of calling function <code>f</code> on each element of <code>itr</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; maximum(length, [&quot;Julion&quot;, &quot;Julia&quot;, &quot;Jule&quot;])
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L604-L614">source</a></section><section><div><pre><code class="language-none">maximum(itr)</code></pre><p>Returns the largest element in a collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; maximum(-20.5:10)
9.5

julia&gt; maximum([1,2,3])
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L630-L643">source</a></section><section><div><pre><code class="language-none">maximum(A::AbstractArray; dims)</code></pre><p>Compute the maximum value of an array over the given dimensions. See also the <a href="math.html#Base.max"><code>max(a,b)</code></a> function to take the maximum of two or more arguments, which can be applied elementwise to arrays via <code>max.(a,b)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; maximum(A, dims=1)
1×2 Array{Int64,2}:
 3  4

julia&gt; maximum(A, dims=2)
2×1 Array{Int64,2}:
 2
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L451-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.maximum!" href="#Base.maximum!"><code>Base.maximum!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">maximum!(r, A)</code></pre><p>Compute the maximum value of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; maximum!([1; 1], A)
2-element Array{Int64,1}:
 2
 4

julia&gt; maximum!([1 1], A)
1×2 Array{Int64,2}:
 3  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L477-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.minimum" href="#Base.minimum"><code>Base.minimum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minimum(f, itr)</code></pre><p>Returns the smallest result of calling function <code>f</code> on each element of <code>itr</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; minimum(length, [&quot;Julion&quot;, &quot;Julia&quot;, &quot;Jule&quot;])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L617-L627">source</a></section><section><div><pre><code class="language-none">minimum(itr)</code></pre><p>Returns the smallest element in a collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; minimum(-20.5:10)
-20.5

julia&gt; minimum([1,2,3])
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L646-L659">source</a></section><section><div><pre><code class="language-none">minimum(A::AbstractArray; dims)</code></pre><p>Compute the minimum value of an array over the given dimensions. See also the <a href="math.html#Base.min"><code>min(a,b)</code></a> function to take the minimum of two or more arguments, which can be applied elementwise to arrays via <code>min.(a,b)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; minimum(A, dims=1)
1×2 Array{Int64,2}:
 1  2

julia&gt; minimum(A, dims=2)
2×1 Array{Int64,2}:
 1
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L501-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.minimum!" href="#Base.minimum!"><code>Base.minimum!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minimum!(r, A)</code></pre><p>Compute the minimum value of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; minimum!([1; 1], A)
2-element Array{Int64,1}:
 1
 3

julia&gt; minimum!([1 1], A)
1×2 Array{Int64,2}:
 1  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L527-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.extrema" href="#Base.extrema"><code>Base.extrema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">extrema(itr) -&gt; Tuple</code></pre><p>Compute both the minimum and maximum element in a single pass, and return them as a 2-tuple.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; extrema(2:10)
(2, 10)

julia&gt; extrema([9,pi,4.5])
(3.141592653589793, 9.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/operators.jl#L437-L450">source</a></section><section><div><pre><code class="language-none">extrema(f, itr) -&gt; Tuple</code></pre><p>Compute both the minimum and maximum of <code>f</code> applied to each element in <code>itr</code> and return them as a 2-tuple. Only one pass is made over <code>itr</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This method requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; extrema(sin, 0:π)
(0.0, 0.9092974268256817)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/operators.jl#L453-L467">source</a></section><section><div><pre><code class="language-none">extrema(A::AbstractArray; dims) -&gt; Array{Tuple}</code></pre><p>Compute the minimum and maximum elements of an array over the given dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = reshape(Vector(1:2:16), (2,2,2))
2×2×2 Array{Int64,3}:
[:, :, 1] =
 1  5
 3  7

[:, :, 2] =
  9  13
 11  15

julia&gt; extrema(A, dims = (1,2))
1×1×2 Array{Tuple{Int64,Int64},3}:
[:, :, 1] =
 (1, 7)

[:, :, 2] =
 (9, 15)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/multidimensional.jl#L1562-L1587">source</a></section><section><div><pre><code class="language-none">extrema(f, A::AbstractArray; dims) -&gt; Array{Tuple}</code></pre><p>Compute the minimum and maximum of <code>f</code> applied to each element in the given dimensions of <code>A</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This method requires Julia 1.2 or later.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/multidimensional.jl#L1590-L1598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.argmax" href="#Base.argmax"><code>Base.argmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">argmax(itr) -&gt; Integer</code></pre><p>Return the index of the maximum element in a collection. If there are multiple maximal elements, then the first one will be returned.</p><p>The collection must not be empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; argmax([8,0.1,-9,pi])
1

julia&gt; argmax([1,7,7,6])
2

julia&gt; argmax([1,7,7,NaN])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L2174-L2193">source</a></section><section><div><pre><code class="language-none">argmax(A; dims) -&gt; indices</code></pre><p>For an array input, return the indices of the maximum elements over the given dimensions. <code>NaN</code> is treated as greater than all other values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; argmax(A, dims=1)
1×2 Array{CartesianIndex{2},2}:
 CartesianIndex(2, 1)  CartesianIndex(2, 2)

julia&gt; argmax(A, dims=2)
2×1 Array{CartesianIndex{2},2}:
 CartesianIndex(1, 2)
 CartesianIndex(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L859-L881">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.argmin" href="#Base.argmin"><code>Base.argmin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">argmin(itr) -&gt; Integer</code></pre><p>Return the index of the minimum element in a collection. If there are multiple minimal elements, then the first one will be returned.</p><p>The collection must not be empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; argmin([8,0.1,-9,pi])
3

julia&gt; argmin([7,1,1,6])
2

julia&gt; argmin([7,1,1,NaN])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L2196-L2215">source</a></section><section><div><pre><code class="language-none">argmin(A; dims) -&gt; indices</code></pre><p>For an array input, return the indices of the minimum elements over the given dimensions. <code>NaN</code> is treated as less than all other values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; argmin(A, dims=1)
1×2 Array{CartesianIndex{2},2}:
 CartesianIndex(1, 1)  CartesianIndex(1, 2)

julia&gt; argmin(A, dims=2)
2×1 Array{CartesianIndex{2},2}:
 CartesianIndex(1, 1)
 CartesianIndex(2, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L834-L856">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findmax" href="#Base.findmax"><code>Base.findmax</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findmax(itr) -&gt; (x, index)</code></pre><p>Return the maximum element of the collection <code>itr</code> and its index. If there are multiple maximal elements, then the first one will be returned. If any data element is <code>NaN</code>, this element is returned. The result is in line with <code>max</code>.</p><p>The collection must not be empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findmax([8,0.1,-9,pi])
(8.0, 1)

julia&gt; findmax([1,7,7,6])
(7, 2)

julia&gt; findmax([1,7,7,NaN])
(NaN, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L2084-L2105">source</a></section><section><div><pre><code class="language-none">findmax(A; dims) -&gt; (maxval, index)</code></pre><p>For an array input, returns the value and index of the maximum over the given dimensions. <code>NaN</code> is treated as greater than all other values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; findmax(A, dims=1)
([3.0 4.0], CartesianIndex{2}[CartesianIndex(2, 1) CartesianIndex(2, 2)])

julia&gt; findmax(A, dims=2)
([2.0; 4.0], CartesianIndex{2}[CartesianIndex(1, 2); CartesianIndex(2, 2)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L797-L816">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findmin" href="#Base.findmin"><code>Base.findmin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findmin(itr) -&gt; (x, index)</code></pre><p>Return the minimum element of the collection <code>itr</code> and its index. If there are multiple minimal elements, then the first one will be returned. If any data element is <code>NaN</code>, this element is returned. The result is in line with <code>min</code>.</p><p>The collection must not be empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; findmin([8,0.1,-9,pi])
(-9.0, 3)

julia&gt; findmin([7,1,1,6])
(1, 2)

julia&gt; findmin([7,1,1,NaN])
(NaN, 4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L2129-L2150">source</a></section><section><div><pre><code class="language-none">findmin(A; dims) -&gt; (minval, index)</code></pre><p>For an array input, returns the value and index of the minimum over the given dimensions. <code>NaN</code> is treated as less than all other values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1.0 2; 3 4]
2×2 Array{Float64,2}:
 1.0  2.0
 3.0  4.0

julia&gt; findmin(A, dims=1)
([1.0 2.0], CartesianIndex{2}[CartesianIndex(1, 1) CartesianIndex(1, 2)])

julia&gt; findmin(A, dims=2)
([1.0; 3.0], CartesianIndex{2}[CartesianIndex(1, 1); CartesianIndex(2, 1)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L748-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findmax!" href="#Base.findmax!"><code>Base.findmax!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findmax!(rval, rind, A) -&gt; (maxval, index)</code></pre><p>Find the maximum of <code>A</code> and the corresponding linear index along singleton dimensions of <code>rval</code> and <code>rind</code>, and store the results in <code>rval</code> and <code>rind</code>. <code>NaN</code> is treated as greater than all other values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L785-L791">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findmin!" href="#Base.findmin!"><code>Base.findmin!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findmin!(rval, rind, A) -&gt; (minval, index)</code></pre><p>Find the minimum of <code>A</code> and the corresponding linear index along singleton dimensions of <code>rval</code> and <code>rind</code>, and store the results in <code>rval</code> and <code>rind</code>. <code>NaN</code> is treated as less than all other values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L736-L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum" href="#Base.sum"><code>Base.sum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sum(f, itr)</code></pre><p>Sum the results of calling function <code>f</code> on each element of <code>itr</code>.</p><p>The return type is <code>Int</code> for signed integers of less than system word size, and <code>UInt</code> for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sum(abs2, [2; 3; 4])
29</code></pre><p>Note the important difference between <code>sum(A)</code> and <code>reduce(+, A)</code> for arrays with small integer eltype:</p><pre><code class="language-julia-repl">julia&gt; sum(Int8[100, 28])
128

julia&gt; reduce(+, Int8[100, 28])
-128</code></pre><p>In the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L456-L485">source</a></section><section><div><pre><code class="language-none">sum(itr)</code></pre><p>Returns the sum of all elements in a collection.</p><p>The return type is <code>Int</code> for signed integers of less than system word size, and <code>UInt</code> for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; sum(1:20)
210</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L488-L502">source</a></section><section><div><pre><code class="language-none">sum(A::AbstractArray; dims)</code></pre><p>Sum elements of an array over the given dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; sum(A, dims=1)
1×2 Array{Int64,2}:
 4  6

julia&gt; sum(A, dims=2)
2×1 Array{Int64,2}:
 3
 7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L355-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sum!" href="#Base.sum!"><code>Base.sum!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sum!(r, A)</code></pre><p>Sum elements of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; sum!([1; 1], A)
2-element Array{Int64,1}:
 3
 7

julia&gt; sum!([1 1], A)
1×2 Array{Int64,2}:
 4  6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L379-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prod" href="#Base.prod"><code>Base.prod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prod(f, itr)</code></pre><p>Returns the product of <code>f</code> applied to each element of <code>itr</code>.</p><p>The return type is <code>Int</code> for signed integers of less than system word size, and <code>UInt</code> for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; prod(abs2, [2; 3; 4])
576</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L507-L521">source</a></section><section><div><pre><code class="language-none">prod(itr)</code></pre><p>Returns the product of all elements of a collection.</p><p>The return type is <code>Int</code> for signed integers of less than system word size, and <code>UInt</code> for unsigned integers of less than system word size.  For all other arguments, a common return type is found to which all arguments are promoted.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; prod(1:20)
2432902008176640000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L524-L538">source</a></section><section><div><pre><code class="language-none">prod(A::AbstractArray; dims)</code></pre><p>Multiply elements of an array over the given dimensions.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; prod(A, dims=1)
1×2 Array{Int64,2}:
 3  8

julia&gt; prod(A, dims=2)
2×1 Array{Int64,2}:
  2
 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L403-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prod!" href="#Base.prod!"><code>Base.prod!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prod!(r, A)</code></pre><p>Multiply elements of <code>A</code> over the singleton dimensions of <code>r</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1 2; 3 4]
2×2 Array{Int64,2}:
 1  2
 3  4

julia&gt; prod!([1; 1], A)
2-element Array{Int64,1}:
  2
 12

julia&gt; prod!([1 1], A)
1×2 Array{Int64,2}:
 3  8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L427-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.any-Tuple{Any}" href="#Base.any-Tuple{Any}"><code>Base.any</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">any(itr) -&gt; Bool</code></pre><p>Test whether any elements of a boolean collection are <code>true</code>, returning <code>true</code> as soon as the first <code>true</code> value in <code>itr</code> is encountered (short-circuiting).</p><p>If the input contains <a href="base.html#Base.missing"><code>missing</code></a> values, return <code>missing</code> if all non-missing values are <code>false</code> (or equivalently, if the input contains no <code>true</code> value), following <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [true,false,false,true]
4-element Array{Bool,1}:
 1
 0
 0
 1

julia&gt; any(a)
true

julia&gt; any((println(i); v) for (i, v) in enumerate(a))
1
true

julia&gt; any([missing, true])
true

julia&gt; any([false, missing])
missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L664-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.any-Tuple{AbstractArray,Any}" href="#Base.any-Tuple{AbstractArray,Any}"><code>Base.any</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">any(p, itr) -&gt; Bool</code></pre><p>Determine whether predicate <code>p</code> returns <code>true</code> for any elements of <code>itr</code>, returning <code>true</code> as soon as the first item in <code>itr</code> for which <code>p</code> returns <code>true</code> is encountered (short-circuiting).</p><p>If the input contains <a href="base.html#Base.missing"><code>missing</code></a> values, return <code>missing</code> if all non-missing values are <code>false</code> (or equivalently, if the input contains no <code>true</code> value), following <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; any(i-&gt;(4&lt;=i&lt;=6), [3,5,7])
true

julia&gt; any(i -&gt; (println(i); i &gt; 3), 1:10)
1
2
3
4
true

julia&gt; any(i -&gt; i &gt; 0, [1, missing])
true

julia&gt; any(i -&gt; i &gt; 0, [-1, missing])
missing

julia&gt; any(i -&gt; i &gt; 0, [-1, 0])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L735-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.any!" href="#Base.any!"><code>Base.any!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">any!(r, A)</code></pre><p>Test whether any values in <code>A</code> along the singleton dimensions of <code>r</code> are <code>true</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [true false; true false]
2×2 Array{Bool,2}:
 1  0
 1  0

julia&gt; any!([1; 1], A)
2-element Array{Int64,1}:
 1
 1

julia&gt; any!([1 1], A)
1×2 Array{Int64,2}:
 1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L623-L645">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.all-Tuple{Any}" href="#Base.all-Tuple{Any}"><code>Base.all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">all(itr) -&gt; Bool</code></pre><p>Test whether all elements of a boolean collection are <code>true</code>, returning <code>false</code> as soon as the first <code>false</code> value in <code>itr</code> is encountered (short-circuiting).</p><p>If the input contains <a href="base.html#Base.missing"><code>missing</code></a> values, return <code>missing</code> if all non-missing values are <code>true</code> (or equivalently, if the input contains no <code>false</code> value), following <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = [true,false,false,true]
4-element Array{Bool,1}:
 1
 0
 0
 1

julia&gt; all(a)
false

julia&gt; all((println(i); v) for (i, v) in enumerate(a))
1
2
false

julia&gt; all([missing, false])
false

julia&gt; all([true, missing])
missing</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L699-L732">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.all-Tuple{AbstractArray,Any}" href="#Base.all-Tuple{AbstractArray,Any}"><code>Base.all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">all(p, itr) -&gt; Bool</code></pre><p>Determine whether predicate <code>p</code> returns <code>true</code> for all elements of <code>itr</code>, returning <code>false</code> as soon as the first item in <code>itr</code> for which <code>p</code> returns <code>false</code> is encountered (short-circuiting).</p><p>If the input contains <a href="base.html#Base.missing"><code>missing</code></a> values, return <code>missing</code> if all non-missing values are <code>true</code> (or equivalently, if the input contains no <code>false</code> value), following <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; all(i-&gt;(4&lt;=i&lt;=6), [4,5,6])
true

julia&gt; all(i -&gt; (println(i); i &lt; 3), 1:10)
1
2
3
false

julia&gt; all(i -&gt; i &gt; 0, [1, missing])
missing

julia&gt; all(i -&gt; i &gt; 0, [-1, missing])
false

julia&gt; all(i -&gt; i &gt; 0, [1, 2])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L783-L814">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.all!" href="#Base.all!"><code>Base.all!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all!(r, A)</code></pre><p>Test whether all values in <code>A</code> along the singleton dimensions of <code>r</code> are <code>true</code>, and write results to <code>r</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [true false; true false]
2×2 Array{Bool,2}:
 1  0
 1  0

julia&gt; all!([1; 1], A)
2-element Array{Int64,1}:
 0
 0

julia&gt; all!([1 1], A)
1×2 Array{Int64,2}:
 1  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reducedim.jl#L575-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.count" href="#Base.count"><code>Base.count</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">count(p, itr) -&gt; Integer
count(itr) -&gt; Integer</code></pre><p>Count the number of elements in <code>itr</code> for which predicate <code>p</code> returns <code>true</code>. If <code>p</code> is omitted, counts the number of <code>true</code> elements in <code>itr</code> (which should be a collection of boolean values).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; count(i-&gt;(4&lt;=i&lt;=6), [2,3,4,5,6])
3

julia&gt; count([true, false, true, true])
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L835-L851">source</a></section><section><div><pre><code class="language-none">count(
    pattern::Union{AbstractString,Regex},
    string::AbstractString;
    overlap::Bool = false,
)</code></pre><p>Return the number of matches for <code>pattern</code> in <code>string</code>. This is equivalent to calling <code>length(findall(pattern, string))</code> but more efficient.</p><p>If <code>overlap=true</code>, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/regex.jl#L358-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.any-Tuple{Any,Any}" href="#Base.any-Tuple{Any,Any}"><code>Base.any</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">any(p, itr) -&gt; Bool</code></pre><p>Determine whether predicate <code>p</code> returns <code>true</code> for any elements of <code>itr</code>, returning <code>true</code> as soon as the first item in <code>itr</code> for which <code>p</code> returns <code>true</code> is encountered (short-circuiting).</p><p>If the input contains <a href="base.html#Base.missing"><code>missing</code></a> values, return <code>missing</code> if all non-missing values are <code>false</code> (or equivalently, if the input contains no <code>true</code> value), following <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; any(i-&gt;(4&lt;=i&lt;=6), [3,5,7])
true

julia&gt; any(i -&gt; (println(i); i &gt; 3), 1:10)
1
2
3
4
true

julia&gt; any(i -&gt; i &gt; 0, [1, missing])
true

julia&gt; any(i -&gt; i &gt; 0, [-1, missing])
missing

julia&gt; any(i -&gt; i &gt; 0, [-1, 0])
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L735-L767">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.all-Tuple{Any,Any}" href="#Base.all-Tuple{Any,Any}"><code>Base.all</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">all(p, itr) -&gt; Bool</code></pre><p>Determine whether predicate <code>p</code> returns <code>true</code> for all elements of <code>itr</code>, returning <code>false</code> as soon as the first item in <code>itr</code> for which <code>p</code> returns <code>false</code> is encountered (short-circuiting).</p><p>If the input contains <a href="base.html#Base.missing"><code>missing</code></a> values, return <code>missing</code> if all non-missing values are <code>true</code> (or equivalently, if the input contains no <code>false</code> value), following <a href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; all(i-&gt;(4&lt;=i&lt;=6), [4,5,6])
true

julia&gt; all(i -&gt; (println(i); i &lt; 3), 1:10)
1
2
3
false

julia&gt; all(i -&gt; i &gt; 0, [1, missing])
missing

julia&gt; all(i -&gt; i &gt; 0, [-1, missing])
false

julia&gt; all(i -&gt; i &gt; 0, [1, 2])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L783-L814">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.foreach" href="#Base.foreach"><code>Base.foreach</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">foreach(f, c...) -&gt; Nothing</code></pre><p>Call function <code>f</code> on each element of iterable <code>c</code>. For multiple iterable arguments, <code>f</code> is called elementwise. <code>foreach</code> should be used instead of <code>map</code> when the results of <code>f</code> are not needed, for example in <code>foreach(println, array)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = 1:3:7;

julia&gt; foreach(x -&gt; println(x^2), a)
1
16
49</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractarray.jl#L1900-L1917">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.map" href="#Base.map"><code>Base.map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map(f, c...) -&gt; collection</code></pre><p>Transform collection <code>c</code> by applying <code>f</code> to each element. For multiple collection arguments, apply <code>f</code> elementwise.</p><p>See also: <a href="arrays.html#Base.mapslices"><code>mapslices</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; map(x -&gt; x * 2, [1, 2, 3])
3-element Array{Int64,1}:
 2
 4
 6

julia&gt; map(+, [1, 2, 3], [10, 20, 30])
3-element Array{Int64,1}:
 11
 22
 33</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractarray.jl#L2075-L2097">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.map!" href="#Base.map!"><code>Base.map!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map!(function, destination, collection...)</code></pre><p>Like <a href="collections.html#Base.map"><code>map</code></a>, but stores the result in <code>destination</code> rather than a new collection. <code>destination</code> must be at least as large as the first collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = zeros(3);

julia&gt; map!(x -&gt; x * 2, a, [1, 2, 3]);

julia&gt; a
3-element Array{Float64,1}:
 2.0
 4.0
 6.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractarray.jl#L2132-L2150">source</a></section><section><div><pre><code class="language-none">map!(f, values(dict::AbstractDict))</code></pre><p>Modifies <code>dict</code> by transforming each value from <code>val</code> to <code>f(val)</code>. Note that the type of <code>dict</code> cannot be changed: if <code>f(val)</code> is not an instance of the value type of <code>dict</code> then it will be converted to the value type if possible and otherwise raise an error.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(:a =&gt; 1, :b =&gt; 2)
Dict{Symbol,Int64} with 2 entries:
  :a =&gt; 1
  :b =&gt; 2

julia&gt; map!(v -&gt; v-1, values(d))
Base.ValueIterator for a Dict{Symbol,Int64} with 2 entries. Values:
  0
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L709-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mapreduce-Tuple{Any,Any,Any}" href="#Base.mapreduce-Tuple{Any,Any,Any}"><code>Base.mapreduce</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mapreduce(f, op, itrs...; [init])</code></pre><p>Apply function <code>f</code> to each element(s) in <code>itrs</code>, and then reduce the result using the binary function <code>op</code>. If provided, <code>init</code> must be a neutral element for <code>op</code> that will be returned for empty collections. It is unspecified whether <code>init</code> is used for non-empty collections. In general, it will be necessary to provide <code>init</code> to work with empty collections.</p><p><a href="collections.html#Base.mapreduce-Tuple{Any,Any,Any}"><code>mapreduce</code></a> is functionally equivalent to calling <code>reduce(op, map(f, itr); init=init)</code>, but will in general execute faster since no intermediate collection needs to be created. See documentation for <a href="collections.html#Base.reduce-Tuple{Any,Any}"><code>reduce</code></a> and <a href="collections.html#Base.map"><code>map</code></a>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p><code>mapreduce</code> with multiple iterators requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; mapreduce(x-&gt;x^2, +, [1:3;]) # == 1 + 4 + 9
14</code></pre><p>The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of <code>f</code> for elements that appear multiple times in <code>itr</code>. Use <a href="collections.html#Base.mapfoldl-Tuple{Any,Any,Any}"><code>mapfoldl</code></a> or <a href="collections.html#Base.mapfoldr-Tuple{Any,Any,Any}"><code>mapfoldr</code></a> instead for guaranteed left or right associativity and invocation of <code>f</code> for every value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L256-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mapfoldl-Tuple{Any,Any,Any}" href="#Base.mapfoldl-Tuple{Any,Any,Any}"><code>Base.mapfoldl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mapfoldl(f, op, itr; [init])</code></pre><p>Like <a href="collections.html#Base.mapreduce-Tuple{Any,Any,Any}"><code>mapreduce</code></a>, but with guaranteed left associativity, as in <a href="collections.html#Base.foldl-Tuple{Any,Any}"><code>foldl</code></a>. If provided, the keyword argument <code>init</code> will be used exactly once. In general, it will be necessary to provide <code>init</code> to work with empty collections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L150-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mapfoldr-Tuple{Any,Any,Any}" href="#Base.mapfoldr-Tuple{Any,Any,Any}"><code>Base.mapfoldr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mapfoldr(f, op, itr; [init])</code></pre><p>Like <a href="collections.html#Base.mapreduce-Tuple{Any,Any,Any}"><code>mapreduce</code></a>, but with guaranteed right associativity, as in <a href="collections.html#Base.foldr-Tuple{Any,Any}"><code>foldr</code></a>. If provided, the keyword argument <code>init</code> will be used exactly once. In general, it will be necessary to provide <code>init</code> to work with empty collections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/reduce.jl#L193-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.first" href="#Base.first"><code>Base.first</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">first(coll)</code></pre><p>Get the first element of an iterable collection. Return the start point of an <a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a> even if it is empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; first(2:2:10)
2

julia&gt; first([1; 2; 3; 4])
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractarray.jl#L325-L339">source</a></section><section><div><pre><code class="language-julia">first(s::AbstractString, n::Integer)</code></pre><p>Get a string consisting of the first <code>n</code> characters of <code>s</code>.</p><pre><code class="language-julia-repl">julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 0)
&quot;&quot;

julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 1)
&quot;∀&quot;

julia&gt; first(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 3)
&quot;∀ϵ≠&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/strings/basic.jl#L596-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.last" href="#Base.last"><code>Base.last</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">last(coll)</code></pre><p>Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling <a href="collections.html#Base.lastindex"><code>lastindex</code></a> to get the last index. Return the end point of an <a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a> even if it is empty.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; last(1:2:10)
9

julia&gt; last([1; 2; 3; 4])
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractarray.jl#L346-L361">source</a></section><section><div><pre><code class="language-julia">last(s::AbstractString, n::Integer)</code></pre><p>Get a string consisting of the last <code>n</code> characters of <code>s</code>.</p><pre><code class="language-julia-repl">julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 0)
&quot;&quot;

julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 1)
&quot;0&quot;

julia&gt; last(&quot;∀ϵ≠0: ϵ²&gt;0&quot;, 3)
&quot;²&gt;0&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/strings/basic.jl#L614-L629">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.front" href="#Base.front"><code>Base.front</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">front(x::Tuple)::Tuple</code></pre><p>Return a <code>Tuple</code> consisting of all but the last component of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Base.front((1,2,3))
(1, 2)

julia&gt; Base.front(())
ERROR: ArgumentError: Cannot call front on an empty tuple.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/tuple.jl#L128-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.tail" href="#Base.tail"><code>Base.tail</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tail(x::Tuple)::Tuple</code></pre><p>Return a <code>Tuple</code> consisting of all but the first component of <code>x</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Base.tail((1,2,3))
(2, 3)

julia&gt; Base.tail(())
ERROR: ArgumentError: Cannot call tail on an empty tuple.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/essentials.jl#L191-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.step" href="#Base.step"><code>Base.step</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">step(r)</code></pre><p>Get the step size of an <a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a> object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; step(1:10)
1

julia&gt; step(1:2:10)
2

julia&gt; step(2.5:0.3:10.9)
0.3

julia&gt; step(range(2.5, stop=10.9, length=85))
0.1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/range.jl#L481-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.collect-Tuple{Any}" href="#Base.collect-Tuple{Any}"><code>Base.collect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">collect(collection)</code></pre><p>Return an <code>Array</code> of all items in a collection or iterator. For dictionaries, returns <code>Pair{KeyType, ValType}</code>. If the argument is array-like or is an iterator with the <a href="collections.html#Base.IteratorSize"><code>HasShape</code></a> trait, the result will have the same shape and number of dimensions as the argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; collect(1:2:13)
7-element Array{Int64,1}:
  1
  3
  5
  7
  9
 11
 13</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L582-L602">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.collect-Tuple{Type,Any}" href="#Base.collect-Tuple{Type,Any}"><code>Base.collect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">collect(element_type, collection)</code></pre><p>Return an <code>Array</code> with the given element type of all items in a collection or iterable. The result has the same shape and number of dimensions as <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; collect(Float64, 1:2:5)
3-element Array{Float64,1}:
 1.0
 3.0
 5.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L547-L561">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filter(f, a::AbstractArray)</code></pre><p>Return a copy of <code>a</code>, removing elements for which <code>f</code> is <code>false</code>. The function <code>f</code> is passed one argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = 1:10
1:10

julia&gt; filter(isodd, a)
5-element Array{Int64,1}:
 1
 3
 5
 7
 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L2349-L2368">source</a></section><section><div><pre><code class="language-none">filter(f, d::AbstractDict)</code></pre><p>Return a copy of <code>d</code>, removing elements for which <code>f</code> is <code>false</code>. The function <code>f</code> is passed <code>key=&gt;value</code> pairs.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(1=&gt;&quot;a&quot;, 2=&gt;&quot;b&quot;)
Dict{Int64,String} with 2 entries:
  2 =&gt; &quot;b&quot;
  1 =&gt; &quot;a&quot;

julia&gt; filter(p-&gt;isodd(p.first), d)
Dict{Int64,String} with 1 entry:
  1 =&gt; &quot;a&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L371-L388">source</a></section><section><div><pre><code class="language-none">filter(f, itr::SkipMissing{&lt;:AbstractArray})</code></pre><p>Return a vector similar to the array wrapped by the given <code>SkipMissing</code> iterator but with all missing elements and those for which <code>f</code> returns <code>false</code> removed.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>This method requires Julia 1.2 or later.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = [1 2; missing 4]
2×2 Array{Union{Missing, Int64},2}:
 1         2
  missing  4

julia&gt; filter(isodd, skipmissing(x))
1-element Array{Int64,1}:
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/missing.jl#L353-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter!" href="#Base.filter!"><code>Base.filter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filter!(f, a::AbstractVector)</code></pre><p>Update <code>a</code>, removing elements for which <code>f</code> is <code>false</code>. The function <code>f</code> is passed one argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; filter!(isodd, Vector(1:10))
5-element Array{Int64,1}:
 1
 3
 5
 7
 9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L2398-L2414">source</a></section><section><div><pre><code class="language-none">filter!(f, d::AbstractDict)</code></pre><p>Update <code>d</code>, removing elements for which <code>f</code> is <code>false</code>. The function <code>f</code> is passed <code>key=&gt;value</code> pairs.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(1=&gt;&quot;a&quot;, 2=&gt;&quot;b&quot;, 3=&gt;&quot;c&quot;)
Dict{Int64,String} with 3 entries:
  2 =&gt; &quot;b&quot;
  3 =&gt; &quot;c&quot;
  1 =&gt; &quot;a&quot;

julia&gt; filter!(p-&gt;isodd(p.first), d)
Dict{Int64,String} with 2 entries:
  3 =&gt; &quot;c&quot;
  1 =&gt; &quot;a&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L329-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace-Tuple{Any,Vararg{Pair,N} where N}" href="#Base.replace-Tuple{Any,Vararg{Pair,N} where N}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replace(A, old_new::Pair...; [count::Integer])</code></pre><p>Return a copy of collection <code>A</code> where, for each pair <code>old=&gt;new</code> in <code>old_new</code>, all occurrences of <code>old</code> are replaced by <code>new</code>. Equality is determined using <a href="base.html#Base.isequal"><code>isequal</code></a>. If <code>count</code> is specified, then replace at most <code>count</code> occurrences in total.</p><p>The element type of the result is chosen using promotion (see <a href="base.html#Base.promote_type"><code>promote_type</code></a>) based on the element type of <code>A</code> and on the types of the <code>new</code> values in pairs. If <code>count</code> is omitted and the element type of <code>A</code> is a <code>Union</code>, the element type of the result will not include singleton types which are replaced with values of a different type: for example, <code>Union{T,Missing}</code> will become <code>T</code> if <code>missing</code> is replaced.</p><p>See also <a href="collections.html#Base.replace!"><code>replace!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; replace([1, 2, 1, 3], 1=&gt;0, 2=&gt;4, count=2)
4-element Array{Int64,1}:
 0
 4
 1
 3

julia&gt; replace([1, missing], missing=&gt;0)
2-element Array{Int64,1}:
 1
 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/set.jl#L493-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace-Tuple{Union{Function, Type},Any}" href="#Base.replace-Tuple{Union{Function, Type},Any}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replace(new::Function, A; [count::Integer])</code></pre><p>Return a copy of <code>A</code> where each value <code>x</code> in <code>A</code> is replaced by <code>new(x)</code> If <code>count</code> is specified, then replace at most <code>count</code> values in total (replacements being defined as <code>new(x) !== x</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; replace(x -&gt; isodd(x) ? 2x : x, [1, 2, 3, 4])
4-element Array{Int64,1}:
 2
 2
 6
 4

julia&gt; replace(Dict(1=&gt;2, 3=&gt;4)) do kv
           first(kv) &lt; 3 ? first(kv)=&gt;3 : kv
       end
Dict{Int64,Int64} with 2 entries:
  3 =&gt; 4
  1 =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/set.jl#L551-L574">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace!" href="#Base.replace!"><code>Base.replace!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">replace!(A, old_new::Pair...; [count::Integer])</code></pre><p>For each pair <code>old=&gt;new</code> in <code>old_new</code>, replace all occurrences of <code>old</code> in collection <code>A</code> by <code>new</code>. Equality is determined using <a href="base.html#Base.isequal"><code>isequal</code></a>. If <code>count</code> is specified, then replace at most <code>count</code> occurrences in total. See also <a href="collections.html#Base.replace-Tuple{Any,Vararg{Pair,N} where N}"><code>replace</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; replace!([1, 2, 1, 3], 1=&gt;0, 2=&gt;4, count=2)
4-element Array{Int64,1}:
 0
 4
 1
 3

julia&gt; replace!(Set([1, 2, 3]), 1=&gt;0)
Set{Int64} with 3 elements:
  0
  2
  3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/set.jl#L423-L447">source</a></section><section><div><pre><code class="language-none">replace!(new::Function, A; [count::Integer])</code></pre><p>Replace each element <code>x</code> in collection <code>A</code> by <code>new(x)</code>. If <code>count</code> is specified, then replace at most <code>count</code> values in total (replacements being defined as <code>new(x) !== x</code>).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; replace!(x -&gt; isodd(x) ? 2x : x, [1, 2, 3, 4])
4-element Array{Int64,1}:
 2
 2
 6
 4

julia&gt; replace!(Dict(1=&gt;2, 3=&gt;4)) do kv
           first(kv) &lt; 3 ? first(kv)=&gt;3 : kv
       end
Dict{Int64,Int64} with 2 entries:
  3 =&gt; 4
  1 =&gt; 3

julia&gt; replace!(x-&gt;2x, Set([3, 6]))
Set{Int64} with 2 elements:
  6
  12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/set.jl#L461-L489">source</a></section></article><h2 id="Indexable-Collections-1"><a class="docs-heading-anchor" href="#Indexable-Collections-1">Indexable Collections</a><a class="docs-heading-anchor-permalink" href="#Indexable-Collections-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.getindex" href="#Base.getindex"><code>Base.getindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getindex(collection, key...)</code></pre><p>Retrieve the value(s) stored at the given key or index within a collection. The syntax <code>a[i,j,...]</code> is converted by the compiler to <code>getindex(a, i, j, ...)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = Dict(&quot;a&quot; =&gt; 1, &quot;b&quot; =&gt; 2)
Dict{String,Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; getindex(A, &quot;a&quot;)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L767-L783">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!" href="#Base.setindex!"><code>Base.setindex!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setindex!(collection, value, key...)</code></pre><p>Store the given value at the given key or index within a collection. The syntax <code>a[i,j,...] = x</code> is converted by the compiler to <code>(setindex!(a, x, i, j, ...); x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L817-L822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.firstindex" href="#Base.firstindex"><code>Base.firstindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">firstindex(collection) -&gt; Integer
firstindex(collection, d) -&gt; Integer</code></pre><p>Return the first index of <code>collection</code>. If <code>d</code> is given, return the first index of <code>collection</code> along dimension <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; firstindex([1,2,4])
1

julia&gt; firstindex(rand(3,4,5), 2)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractarray.jl#L305-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.lastindex" href="#Base.lastindex"><code>Base.lastindex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lastindex(collection) -&gt; Integer
lastindex(collection, d) -&gt; Integer</code></pre><p>Return the last index of <code>collection</code>. If <code>d</code> is given, return the last index of <code>collection</code> along dimension <code>d</code>.</p><p>The syntaxes <code>A[end]</code> and <code>A[end, end]</code> lower to <code>A[lastindex(A)]</code> and <code>A[lastindex(A, 1), lastindex(A, 2)]</code>, respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; lastindex([1,2,4])
3

julia&gt; lastindex(rand(3,4,5), 2)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractarray.jl#L284-L301">source</a></section></article><p>Fully implemented by:</p><ul><li><a href="arrays.html#Core.Array"><code>Array</code></a></li><li><a href="arrays.html#Base.BitArray"><code>BitArray</code></a></li><li><a href="arrays.html#Core.AbstractArray"><code>AbstractArray</code></a></li><li><code>SubArray</code></li></ul><p>Partially implemented by:</p><ul><li><a href="collections.html#Base.AbstractRange"><code>AbstractRange</code></a></li><li><a href="collections.html#Base.UnitRange"><code>UnitRange</code></a></li><li><code>Tuple</code></li><li><code>AbstractString</code></li><li><a href="collections.html#Base.Dict"><code>Dict</code></a></li><li><a href="collections.html#Base.IdDict"><code>IdDict</code></a></li><li><a href="collections.html#Base.WeakKeyDict"><code>WeakKeyDict</code></a></li><li><a href="base.html#Core.NamedTuple"><code>NamedTuple</code></a></li></ul><h2 id="Dictionaries-1"><a class="docs-heading-anchor" href="#Dictionaries-1">Dictionaries</a><a class="docs-heading-anchor-permalink" href="#Dictionaries-1" title="Permalink"></a></h2><p><a href="collections.html#Base.Dict"><code>Dict</code></a> is the standard dictionary. Its implementation uses <a href="base.html#Base.hash"><code>hash</code></a> as the hashing function for the key, and <a href="base.html#Base.isequal"><code>isequal</code></a> to determine equality. Define these two functions for custom types to override how they are stored in a hash table.</p><p><a href="collections.html#Base.IdDict"><code>IdDict</code></a> is a special hash table where the keys are always object identities.</p><p><a href="collections.html#Base.WeakKeyDict"><code>WeakKeyDict</code></a> is a hash table implementation where the keys are weak references to objects, and thus may be garbage collected even when referenced in a hash table. Like <code>Dict</code> it uses <code>hash</code> for hashing and <code>isequal</code> for equality, unlike <code>Dict</code> it does not convert keys on insertion.</p><p><a href="collections.html#Base.Dict"><code>Dict</code></a>s can be created by passing pair objects constructed with <code>=&gt;</code> to a <a href="collections.html#Base.Dict"><code>Dict</code></a> constructor: <code>Dict(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)</code>. This call will attempt to infer type information from the keys and values (i.e. this example creates a <code>Dict{String, Int64}</code>). To explicitly specify types use the syntax <code>Dict{KeyType,ValueType}(...)</code>. For example, <code>Dict{String,Int32}(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)</code>.</p><p>Dictionaries may also be created with generators. For example, <code>Dict(i =&gt; f(i) for i = 1:10)</code>.</p><p>Given a dictionary <code>D</code>, the syntax <code>D[x]</code> returns the value of key <code>x</code> (if it exists) or throws an error, and <code>D[x] = y</code> stores the key-value pair <code>x =&gt; y</code> in <code>D</code> (replacing any existing value for the key <code>x</code>).  Multiple arguments to <code>D[...]</code> are converted to tuples; for example, the syntax <code>D[x,y]</code>  is equivalent to <code>D[(x,y)]</code>, i.e. it refers to the value keyed by the tuple <code>(x,y)</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractDict" href="#Base.AbstractDict"><code>Base.AbstractDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractDict{K, V}</code></pre><p>Supertype for dictionary-like types with keys of type <code>K</code> and values of type <code>V</code>. <a href="collections.html#Base.Dict"><code>Dict</code></a>, <a href="collections.html#Base.IdDict"><code>IdDict</code></a> and other types are subtypes of this. An <code>AbstractDict{K, V}</code> should be an iterator of <code>Pair{K, V}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/essentials.jl#L17-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Dict" href="#Base.Dict"><code>Base.Dict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dict([itr])</code></pre><p><code>Dict{K,V}()</code> constructs a hash table with keys of type <code>K</code> and values of type <code>V</code>. Keys are compared with <a href="base.html#Base.isequal"><code>isequal</code></a> and hashed with <a href="base.html#Base.hash"><code>hash</code></a>.</p><p>Given a single iterable argument, constructs a <a href="collections.html#Base.Dict"><code>Dict</code></a> whose key-value pairs are taken from 2-tuples <code>(key,value)</code> generated by the argument.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Dict([(&quot;A&quot;, 1), (&quot;B&quot;, 2)])
Dict{String,Int64} with 2 entries:
  &quot;B&quot; =&gt; 2
  &quot;A&quot; =&gt; 1</code></pre><p>Alternatively, a sequence of pair arguments may be passed.</p><pre><code class="language-julia-repl">julia&gt; Dict(&quot;A&quot;=&gt;1, &quot;B&quot;=&gt;2)
Dict{String,Int64} with 2 entries:
  &quot;B&quot; =&gt; 2
  &quot;A&quot; =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L52-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.IdDict" href="#Base.IdDict"><code>Base.IdDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IdDict([itr])</code></pre><p><code>IdDict{K,V}()</code> constructs a hash table using object-id as hash and <code>===</code> as equality with keys of type <code>K</code> and values of type <code>V</code>.</p><p>See <a href="collections.html#Base.Dict"><code>Dict</code></a> for further help.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L499-L506">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.WeakKeyDict" href="#Base.WeakKeyDict"><code>Base.WeakKeyDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WeakKeyDict([itr])</code></pre><p><code>WeakKeyDict()</code> constructs a hash table where the keys are weak references to objects which may be garbage collected even when referenced in a hash table.</p><p>See <a href="collections.html#Base.Dict"><code>Dict</code></a> for further help.  Note, unlike <a href="collections.html#Base.Dict"><code>Dict</code></a>, <code>WeakKeyDict</code> does not convert keys on insertion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/weakkeydict.jl#L5-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.ImmutableDict" href="#Base.ImmutableDict"><code>Base.ImmutableDict</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ImmutableDict</code></pre><p>ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key</p><pre><code class="language-none">ImmutableDict(KV::Pair)</code></pre><p>Create a new entry in the Immutable Dictionary for the key =&gt; value pair</p><ul><li>use <code>(key =&gt; value) in dict</code> to see if this particular combination is in the properties set</li><li>use <code>get(dict, key, default)</code> to retrieve the most recent value for a particular key</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L733-L748">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.haskey" href="#Base.haskey"><code>Base.haskey</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">haskey(collection, key) -&gt; Bool</code></pre><p>Determine whether a collection has a mapping for a given <code>key</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; D = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char,Int64} with 2 entries:
  &#39;a&#39; =&gt; 2
  &#39;b&#39; =&gt; 3

julia&gt; haskey(D, &#39;a&#39;)
true

julia&gt; haskey(D, &#39;c&#39;)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L526-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get-Tuple{Any,Any,Any}" href="#Base.get-Tuple{Any,Any,Any}"><code>Base.get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get(collection, key, default)</code></pre><p>Return the value stored for the given key, or the given default value if no mapping for the key is present.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2);

julia&gt; get(d, &quot;a&quot;, 3)
1

julia&gt; get(d, &quot;c&quot;, 3)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L480-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get(collection, key, default)</code></pre><p>Return the value stored for the given key, or the given default value if no mapping for the key is present.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2);

julia&gt; get(d, &quot;a&quot;, 3)
1

julia&gt; get(d, &quot;c&quot;, 3)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L480-L496">source</a></section><section><div><pre><code class="language-none">get(f::Function, collection, key)</code></pre><p>Return the value stored for the given key, or if no mapping for the key is present, return <code>f()</code>.  Use <a href="collections.html#Base.get!-Tuple{Any,Any,Any}"><code>get!</code></a> to also store the default value in the dictionary.</p><p>This is intended to be called using <code>do</code> block syntax</p><pre><code class="language-julia">get(dict, key) do
    # default value calculated here
    time()
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L504-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get!-Tuple{Any,Any,Any}" href="#Base.get!-Tuple{Any,Any,Any}"><code>Base.get!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get!(collection, key, default)</code></pre><p>Return the value stored for the given key, or if no mapping for the key is present, store <code>key =&gt; default</code>, and return <code>default</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; get!(d, &quot;a&quot;, 5)
1

julia&gt; get!(d, &quot;d&quot;, 4)
4

julia&gt; d
Dict{String,Int64} with 4 entries:
  &quot;c&quot; =&gt; 3
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1
  &quot;d&quot; =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L394-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.get!-Tuple{Function,Any,Any}" href="#Base.get!-Tuple{Function,Any,Any}"><code>Base.get!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get!(f::Function, collection, key)</code></pre><p>Return the value stored for the given key, or if no mapping for the key is present, store <code>key =&gt; f()</code>, and return <code>f()</code>.</p><p>This is intended to be called using <code>do</code> block syntax:</p><pre><code class="language-julia">get!(dict, key) do
    # default value calculated here
    time()
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L422-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getkey" href="#Base.getkey"><code>Base.getkey</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getkey(collection, key, default)</code></pre><p>Return the key matching argument <code>key</code> if one exists in <code>collection</code>, otherwise return <code>default</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; D = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char,Int64} with 2 entries:
  &#39;a&#39; =&gt; 2
  &#39;b&#39; =&gt; 3

julia&gt; getkey(D, &#39;a&#39;, 1)
&#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)

julia&gt; getkey(D, &#39;d&#39;, &#39;a&#39;)
&#39;a&#39;: ASCII/Unicode U+0061 (category Ll: Letter, lowercase)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L548-L566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.delete!" href="#Base.delete!"><code>Base.delete!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delete!(collection, key)</code></pre><p>Delete the mapping for the given key in a collection, if any, and return the collection.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2)
Dict{String,Int64} with 2 entries:
  &quot;b&quot; =&gt; 2
  &quot;a&quot; =&gt; 1

julia&gt; delete!(d, &quot;b&quot;)
Dict{String,Int64} with 1 entry:
  &quot;a&quot; =&gt; 1

julia&gt; delete!(d, &quot;b&quot;) # d is left unchanged
Dict{String,Int64} with 1 entry:
  &quot;a&quot; =&gt; 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L631-L651">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pop!-Tuple{Any,Any,Any}" href="#Base.pop!-Tuple{Any,Any,Any}"><code>Base.pop!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pop!(collection, key[, default])</code></pre><p>Delete and return the mapping for <code>key</code> if it exists in <code>collection</code>, otherwise return <code>default</code>, or throw an error if <code>default</code> is not specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; pop!(d, &quot;a&quot;)
1

julia&gt; pop!(d, &quot;d&quot;)
ERROR: KeyError: key &quot;d&quot; not found
Stacktrace:
[...]

julia&gt; pop!(d, &quot;e&quot;, 4)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L583-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">keys(iterator)</code></pre><p>For an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.values" href="#Base.values"><code>Base.values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">values(iterator)</code></pre><p>For an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its &quot;values&quot;.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2);

julia&gt; values(d)
Base.ValueIterator for a Dict{String,Int64} with 2 entries. Values:
  2
  1

julia&gt; values([2])
1-element Array{Int64,1}:
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/essentials.jl#L742-L763">source</a></section><section><div><pre><code class="language-none">values(a::AbstractDict)</code></pre><p>Return an iterator over all values in a collection. <code>collect(values(a))</code> returns an array of values. When the values are stored internally in a hash table, as is the case for <code>Dict</code>, the order in which they are returned may vary. But <code>keys(a)</code> and <code>values(a)</code> both iterate <code>a</code> and return the elements in the same order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; D = Dict(&#39;a&#39;=&gt;2, &#39;b&#39;=&gt;3)
Dict{Char,Int64} with 2 entries:
  &#39;a&#39; =&gt; 2
  &#39;b&#39; =&gt; 3

julia&gt; collect(values(D))
2-element Array{Int64,1}:
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L101-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pairs" href="#Base.pairs"><code>Base.pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pairs(collection)</code></pre><p>Return an iterator over <code>key =&gt; value</code> pairs for any collection that maps a set of keys to a set of values. This includes arrays, where the keys are the array indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L127-L133">source</a></section><section><div><pre><code class="language-none">pairs(IndexLinear(), A)
pairs(IndexCartesian(), A)
pairs(IndexStyle(A), A)</code></pre><p>An iterator that accesses each element of the array <code>A</code>, returning <code>i =&gt; x</code>, where <code>i</code> is the index for the element and <code>x = A[i]</code>. Identical to <code>pairs(A)</code>, except that the style of index can be selected. Also similar to <code>enumerate(A)</code>, except <code>i</code> will be a valid index for <code>A</code>, while <code>enumerate</code> always counts from 1 regardless of the indices of <code>A</code>.</p><p>Specifying <a href="arrays.html#Base.IndexLinear"><code>IndexLinear()</code></a> ensures that <code>i</code> will be an integer; specifying <a href="arrays.html#Base.IndexCartesian"><code>IndexCartesian()</code></a> ensures that <code>i</code> will be a <a href="arrays.html#Base.IteratorsMD.CartesianIndex"><code>CartesianIndex</code></a>; specifying <code>IndexStyle(A)</code> chooses whichever has been defined as the native indexing style for array <code>A</code>.</p><p>Mutation of the bounds of the underlying array will invalidate this iterator.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [&quot;a&quot; &quot;d&quot;; &quot;b&quot; &quot;e&quot;; &quot;c&quot; &quot;f&quot;];

julia&gt; for (index, value) in pairs(IndexStyle(A), A)
           println(&quot;$index $value&quot;)
       end
1 a
2 b
3 c
4 d
5 e
6 f

julia&gt; S = view(A, 1:2, :);

julia&gt; for (index, value) in pairs(IndexStyle(S), S)
           println(&quot;$index $value&quot;)
       end
CartesianIndex(1, 1) a
CartesianIndex(2, 1) b
CartesianIndex(1, 2) d
CartesianIndex(2, 2) e</code></pre><p>See also: <a href="arrays.html#Base.IndexStyle"><code>IndexStyle</code></a>, <a href="arrays.html#Base.axes-Tuple{Any}"><code>axes</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/iterators.jl#L172-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge" href="#Base.merge"><code>Base.merge</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">merge(d::AbstractDict, others::AbstractDict...)</code></pre><p>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Dict(&quot;foo&quot; =&gt; 0.0, &quot;bar&quot; =&gt; 42.0)
Dict{String,Float64} with 2 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; b = Dict(&quot;baz&quot; =&gt; 17, &quot;bar&quot; =&gt; 4711)
Dict{String,Int64} with 2 entries:
  &quot;bar&quot; =&gt; 4711
  &quot;baz&quot; =&gt; 17

julia&gt; merge(a, b)
Dict{String,Float64} with 3 entries:
  &quot;bar&quot; =&gt; 4711.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; merge(b, a)
Dict{String,Float64} with 3 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L253-L285">source</a></section><section><div><pre><code class="language-none">merge(combine, d::AbstractDict, others::AbstractDict...)</code></pre><p>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Dict(&quot;foo&quot; =&gt; 0.0, &quot;bar&quot; =&gt; 42.0)
Dict{String,Float64} with 2 entries:
  &quot;bar&quot; =&gt; 42.0
  &quot;foo&quot; =&gt; 0.0

julia&gt; b = Dict(&quot;baz&quot; =&gt; 17, &quot;bar&quot; =&gt; 4711)
Dict{String,Int64} with 2 entries:
  &quot;bar&quot; =&gt; 4711
  &quot;baz&quot; =&gt; 17

julia&gt; merge(+, a, b)
Dict{String,Float64} with 3 entries:
  &quot;bar&quot; =&gt; 4753.0
  &quot;baz&quot; =&gt; 17.0
  &quot;foo&quot; =&gt; 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L289-L315">source</a></section><section><div><pre><code class="language-none">merge(a::NamedTuple, bs::NamedTuple...)</code></pre><p>Construct a new named tuple by merging two or more existing ones, in a left-associative manner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields present in both the leftmost and rightmost named tuples take the same position as they are found in the leftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that contains that field. Fields present in only the rightmost named tuple of a pair are appended at the end. A fallback is implemented for when only a single named tuple is supplied, with signature <code>merge(a::NamedTuple)</code>.</p><div class="admonition is-compat"><header class="admonition-header">Julia 1.1</header><div class="admonition-body"><p>Merging 3 or more <code>NamedTuple</code> requires at least Julia 1.1.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; merge((a=1, b=2, c=3), (b=4, d=5))
(a = 1, b = 4, c = 3, d = 5)</code></pre><pre><code class="language-julia-repl">julia&gt; merge((a=1, b=2), (b=3, c=(d=1,)), (c=(d=2,),))
(a = 1, b = 3, c = (d = 2,))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/namedtuple.jl#L195-L219">source</a></section><section><div><pre><code class="language-none">merge(a::NamedTuple, iterable)</code></pre><p>Interpret an iterable of key-value pairs as a named tuple, and perform a merge.</p><pre><code class="language-julia-repl">julia&gt; merge((a=1, b=2, c=3), [:b=&gt;4, :d=&gt;5])
(a = 1, b = 4, c = 3, d = 5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/namedtuple.jl#L241-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{AbstractDict,Vararg{AbstractDict,N} where N}" href="#Base.merge!-Tuple{AbstractDict,Vararg{AbstractDict,N} where N}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge!(d::AbstractDict, others::AbstractDict...)</code></pre><p>Update collection with pairs from the other collections. See also <a href="collections.html#Base.merge"><code>merge</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d1 = Dict(1 =&gt; 2, 3 =&gt; 4);

julia&gt; d2 = Dict(1 =&gt; 4, 4 =&gt; 5);

julia&gt; merge!(d1, d2);

julia&gt; d1
Dict{Int64,Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 4
  1 =&gt; 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L156-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge!-Tuple{Function,AbstractDict,Vararg{AbstractDict,N} where N}" href="#Base.merge!-Tuple{Function,AbstractDict,Vararg{AbstractDict,N} where N}"><code>Base.merge!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">merge!(combine, d::AbstractDict, others::AbstractDict...)</code></pre><p>Update collection with pairs from the other collections. Values with the same key will be combined using the combiner function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d1 = Dict(1 =&gt; 2, 3 =&gt; 4);

julia&gt; d2 = Dict(1 =&gt; 4, 4 =&gt; 5);

julia&gt; merge!(+, d1, d2);

julia&gt; d1
Dict{Int64,Int64} with 3 entries:
  4 =&gt; 5
  3 =&gt; 4
  1 =&gt; 6

julia&gt; merge!(-, d1, d1);

julia&gt; d1
Dict{Int64,Int64} with 3 entries:
  4 =&gt; 0
  3 =&gt; 0
  1 =&gt; 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L186-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sizehint!" href="#Base.sizehint!"><code>Base.sizehint!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sizehint!(s, n)</code></pre><p>Suggest that collection <code>s</code> reserve capacity for at least <code>n</code> elements. This can improve performance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L1073-L1077">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keytype" href="#Base.keytype"><code>Base.keytype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">keytype(T::Type{&lt;:AbstractArray})
keytype(A::AbstractArray)</code></pre><p>Return the key type of an array. This is equal to the <code>eltype</code> of the result of <code>keys(...)</code>, and is provided mainly for compatibility with the dictionary interface.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; keytype([1, 2, 3]) == Int
true

julia&gt; keytype([1 2; 3 4])
CartesianIndex{2}</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>For arrays, this function requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractarray.jl#L104-L123">source</a></section><section><div><pre><code class="language-none">keytype(type)</code></pre><p>Get the key type of an dictionary type. Behaves similarly to <a href="collections.html#Base.eltype"><code>eltype</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; keytype(Dict(Int32(1) =&gt; &quot;foo&quot;))
Int32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L225-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.valtype" href="#Base.valtype"><code>Base.valtype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">valtype(T::Type{&lt;:AbstractArray})
valtype(A::AbstractArray)</code></pre><p>Return the value type of an array. This is identical to <code>eltype</code> and is provided mainly for compatibility with the dictionary interface.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; valtype([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;])
String</code></pre><div class="admonition is-compat"><header class="admonition-header">Julia 1.2</header><div class="admonition-body"><p>For arrays, this function requires at least Julia 1.2.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractarray.jl#L131-L146">source</a></section><section><div><pre><code class="language-none">valtype(type)</code></pre><p>Get the value type of an dictionary type. Behaves similarly to <a href="collections.html#Base.eltype"><code>eltype</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; valtype(Dict(Int32(1) =&gt; &quot;foo&quot;))
String</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractdict.jl#L239-L249">source</a></section></article><p>Fully implemented by:</p><ul><li><a href="collections.html#Base.IdDict"><code>IdDict</code></a></li><li><a href="collections.html#Base.Dict"><code>Dict</code></a></li><li><a href="collections.html#Base.WeakKeyDict"><code>WeakKeyDict</code></a></li></ul><p>Partially implemented by:</p><ul><li><a href="collections.html#Base.BitSet"><code>BitSet</code></a></li><li><a href="collections.html#Base.Set"><code>Set</code></a></li><li><a href="base.html#Base.EnvDict"><code>EnvDict</code></a></li><li><a href="arrays.html#Core.Array"><code>Array</code></a></li><li><a href="arrays.html#Base.BitArray"><code>BitArray</code></a></li><li><a href="collections.html#Base.ImmutableDict"><code>ImmutableDict</code></a></li><li><a href="collections.html#Base.Iterators.Pairs"><code>Iterators.Pairs</code></a></li></ul><h2 id="Set-Like-Collections-1"><a class="docs-heading-anchor" href="#Set-Like-Collections-1">Set-Like Collections</a><a class="docs-heading-anchor-permalink" href="#Set-Like-Collections-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.AbstractSet" href="#Base.AbstractSet"><code>Base.AbstractSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractSet{T}</code></pre><p>Supertype for set-like types whose elements are of type <code>T</code>. <a href="collections.html#Base.Set"><code>Set</code></a>, <a href="collections.html#Base.BitSet"><code>BitSet</code></a> and other types are subtypes of this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/essentials.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Set" href="#Base.Set"><code>Base.Set</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Set([itr])</code></pre><p>Construct a <a href="collections.html#Base.Set"><code>Set</code></a> of the values generated by the given iterable object, or an empty set. Should be used instead of <a href="collections.html#Base.BitSet"><code>BitSet</code></a> for sparse integer sets, or for sets of arbitrary objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/set.jl#L14-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.BitSet" href="#Base.BitSet"><code>Base.BitSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BitSet([itr])</code></pre><p>Construct a sorted set of <code>Int</code>s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large integers), use <a href="collections.html#Base.Set"><code>Set</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/bitset.jl#L21-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union" href="#Base.union"><code>Base.union</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">union(s, itrs...)
∪(s, itrs...)</code></pre><p>Construct the union of sets. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; union([1, 2], [3, 4])
4-element Array{Int64,1}:
 1
 2
 3
 4

julia&gt; union([1, 2], [2, 4])
3-element Array{Int64,1}:
 1
 2
 4

julia&gt; union([4, 2], 1:2)
3-element Array{Int64,1}:
 4
 2
 1

julia&gt; union(Set([1, 2]), 2:3)
Set{Int64} with 3 elements:
  2
  3
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L10-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union!" href="#Base.union!"><code>Base.union!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">union!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>Construct the union of passed in sets and overwrite <code>s</code> with the result. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Set([1, 3, 4, 5]);

julia&gt; union!(a, 1:2:8);

julia&gt; a
Set{Int64} with 5 elements:
  7
  4
  3
  5
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L53-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect" href="#Base.intersect"><code>Base.intersect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intersect(s, itrs...)
∩(s, itrs...)</code></pre><p>Construct the intersection of sets. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; intersect([1, 2, 3], [3, 4, 5])
1-element Array{Int64,1}:
 3

julia&gt; intersect([1, 4, 4, 5, 6], [4, 6, 6, 7, 8])
2-element Array{Int64,1}:
 4
 6

julia&gt; intersect(Set([1, 2]), BitSet([2, 3]))
Set{Int64} with 1 element:
  2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L97-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setdiff" href="#Base.setdiff"><code>Base.setdiff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setdiff(s, itrs...)</code></pre><p>Construct the set of elements in <code>s</code> but not in any of the iterables in <code>itrs</code>. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; setdiff([1,2,3], [3,4,5])
2-element Array{Int64,1}:
 1
 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L142-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setdiff!" href="#Base.setdiff!"><code>Base.setdiff!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setdiff!(s, itrs...)</code></pre><p>Remove from set <code>s</code> (in-place) each element of each iterable from <code>itrs</code>. Maintain order with arrays.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; a = Set([1, 3, 4, 5]);

julia&gt; setdiff!(a, 1:2:6);

julia&gt; a
Set{Int64} with 1 element:
  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L159-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.symdiff" href="#Base.symdiff"><code>Base.symdiff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">symdiff(s, itrs...)</code></pre><p>Construct the symmetric difference of elements in the passed in sets. When <code>s</code> is not an <code>AbstractSet</code>, the order is maintained. Note that in this case the multiplicity of elements matters.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; symdiff([1,2,3], [3,4,5], [4,5,6])
3-element Array{Int64,1}:
 1
 2
 6

julia&gt; symdiff([1,2,1], [2, 1, 2])
2-element Array{Int64,1}:
 1
 2

julia&gt; symdiff(unique([1,2,1]), unique([2, 1, 2]))
0-element Array{Int64,1}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L190-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.symdiff!" href="#Base.symdiff!"><code>Base.symdiff!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">symdiff!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>Construct the symmetric difference of the passed in sets, and overwrite <code>s</code> with the result. When <code>s</code> is an array, the order is maintained. Note that in this case the multiplicity of elements matters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L217-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.intersect!" href="#Base.intersect!"><code>Base.intersect!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intersect!(s::Union{AbstractSet,AbstractVector}, itrs...)</code></pre><p>Intersect all passed in sets and overwrite <code>s</code> with the result. Maintain order with arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.issubset" href="#Base.issubset"><code>Base.issubset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issubset(a, b) -&gt; Bool
⊆(a, b) -&gt; Bool
⊇(b, a) -&gt; Bool</code></pre><p>Determine whether every element of <code>a</code> is also in <code>b</code>, using <a href="collections.html#Base.in"><code>in</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; issubset([1, 2], [1, 2, 3])
true

julia&gt; [1, 2, 3] ⊆ [1, 2]
false

julia&gt; [1, 2, 3] ⊇ [1, 2]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L242-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊈" href="#Base.:⊈"><code>Base.:⊈</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊈(a, b) -&gt; Bool
⊉(b, a) -&gt; Bool</code></pre><p>Negation of <code>⊆</code> and <code>⊇</code>, i.e. checks that <code>a</code> is not a subset of <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; (1, 2) ⊈ (2, 3)
true

julia&gt; (1, 2) ⊈ (1, 2, 3)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L324-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:⊊" href="#Base.:⊊"><code>Base.:⊊</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">⊊(a, b) -&gt; Bool
⊋(b, a) -&gt; Bool</code></pre><p>Determines if <code>a</code> is a subset of, but not equal to, <code>b</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; (1, 2) ⊊ (1, 2, 3)
true

julia&gt; (1, 2) ⊊ (1, 2)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L301-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.issetequal" href="#Base.issetequal"><code>Base.issetequal</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issetequal(a, b) -&gt; Bool</code></pre><p>Determine whether <code>a</code> and <code>b</code> have the same elements. Equivalent to <code>a ⊆ b &amp;&amp; b ⊆ a</code> but more efficient when possible.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; issetequal([1, 2], [1, 2, 3])
false

julia&gt; issetequal([1, 2], [2, 1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/abstractset.jl#L346-L360">source</a></section></article><p>Fully implemented by:</p><ul><li><a href="collections.html#Base.BitSet"><code>BitSet</code></a></li><li><a href="collections.html#Base.Set"><code>Set</code></a></li></ul><p>Partially implemented by:</p><ul><li><a href="arrays.html#Core.Array"><code>Array</code></a></li></ul><h2 id="Dequeues-1"><a class="docs-heading-anchor" href="#Dequeues-1">Dequeues</a><a class="docs-heading-anchor-permalink" href="#Dequeues-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.push!" href="#Base.push!"><code>Base.push!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">push!(collection, items...) -&gt; collection</code></pre><p>Insert one or more <code>items</code> in <code>collection</code>. If <code>collection</code> is an ordered container, the items are inserted at the end (in the given order).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; push!([1, 2, 3], 4, 5, 6)
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6</code></pre><p>If <code>collection</code> is ordered, use <a href="collections.html#Base.append!"><code>append!</code></a> to add all the elements of another collection to it. The result of the preceding example is equivalent to <code>append!([1, 2, 3], [4, 5, 6])</code>. For <code>AbstractSet</code> objects, <a href="collections.html#Base.union!"><code>union!</code></a> can be used instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L886-L907">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pop!" href="#Base.pop!"><code>Base.pop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pop!(collection) -&gt; item</code></pre><p>Remove an item in <code>collection</code> and return it. If <code>collection</code> is an ordered container, the last item is returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A=[1, 2, 3]
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; pop!(A)
3

julia&gt; A
2-element Array{Int64,1}:
 1
 2

julia&gt; S = Set([1, 2])
Set{Int64} with 2 elements:
  2
  1

julia&gt; pop!(S)
2

julia&gt; S
Set{Int64} with 1 element:
  1

julia&gt; pop!(Dict(1=&gt;2))
1 =&gt; 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L1085-L1122">source</a></section><section><div><pre><code class="language-julia">pop!(collection, key[, default])</code></pre><p>Delete and return the mapping for <code>key</code> if it exists in <code>collection</code>, otherwise return <code>default</code>, or throw an error if <code>default</code> is not specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; d = Dict(&quot;a&quot;=&gt;1, &quot;b&quot;=&gt;2, &quot;c&quot;=&gt;3);

julia&gt; pop!(d, &quot;a&quot;)
1

julia&gt; pop!(d, &quot;d&quot;)
ERROR: KeyError: key &quot;d&quot; not found
Stacktrace:
[...]

julia&gt; pop!(d, &quot;e&quot;, 4)
4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/dict.jl#L583-L604">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pushfirst!" href="#Base.pushfirst!"><code>Base.pushfirst!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pushfirst!(collection, items...) -&gt; collection</code></pre><p>Insert one or more <code>items</code> at the beginning of <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; pushfirst!([1, 2, 3, 4], 5, 6)
6-element Array{Int64,1}:
 5
 6
 1
 2
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L1132-L1148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.popfirst!" href="#Base.popfirst!"><code>Base.popfirst!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">popfirst!(collection) -&gt; item</code></pre><p>Remove the first <code>item</code> from <code>collection</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [1, 2, 3, 4, 5, 6]
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6

julia&gt; popfirst!(A)
1

julia&gt; A
5-element Array{Int64,1}:
 2
 3
 4
 5
 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L1156-L1183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.insert!" href="#Base.insert!"><code>Base.insert!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert!(a::Vector, index::Integer, item)</code></pre><p>Insert an <code>item</code> into <code>a</code> at the given <code>index</code>. <code>index</code> is the index of <code>item</code> in the resulting <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; insert!([6, 5, 4, 2, 1], 4, 3)
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L1193-L1210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.deleteat!" href="#Base.deleteat!"><code>Base.deleteat!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">deleteat!(a::Vector, i::Integer)</code></pre><p>Remove the item at the given <code>i</code> and return the modified <code>a</code>. Subsequent items are shifted to fill the resulting gap.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 2)
5-element Array{Int64,1}:
 6
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L1220-L1236">source</a></section><section><div><pre><code class="language-none">deleteat!(a::Vector, inds)</code></pre><p>Remove the items at the indices given by <code>inds</code>, and return the modified <code>a</code>. Subsequent items are shifted to fill the resulting gap.</p><p><code>inds</code> can be either an iterator or a collection of sorted and unique integer indices, or a boolean vector of the same length as <code>a</code> with <code>true</code> indicating entries to delete.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; deleteat!([6, 5, 4, 3, 2, 1], 1:2:5)
3-element Array{Int64,1}:
 5
 3
 1

julia&gt; deleteat!([6, 5, 4, 3, 2, 1], [true, false, true, false, true, false])
3-element Array{Int64,1}:
 5
 3
 1

julia&gt; deleteat!([6, 5, 4, 3, 2, 1], (2, 2))
ERROR: ArgumentError: indices must be unique and sorted
Stacktrace:
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L1245-L1273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.splice!" href="#Base.splice!"><code>Base.splice!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">splice!(a::Vector, index::Integer, [replacement]) -&gt; item</code></pre><p>Remove the item at the given index, and return the removed item. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed item.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [6, 5, 4, 3, 2, 1]; splice!(A, 5)
2

julia&gt; A
5-element Array{Int64,1}:
 6
 5
 4
 3
 1

julia&gt; splice!(A, 5, -1)
1

julia&gt; A
5-element Array{Int64,1}:
  6
  5
  4
  3
 -1

julia&gt; splice!(A, 1, [-1, -2, -3])
6

julia&gt; A
7-element Array{Int64,1}:
 -1
 -2
 -3
  5
  4
  3
 -1</code></pre><p>To insert <code>replacement</code> before an index <code>n</code> without removing any items, use <code>splice!(collection, n:n-1, replacement)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L1324-L1372">source</a></section><section><div><pre><code class="language-none">splice!(a::Vector, range, [replacement]) -&gt; items</code></pre><p>Remove items in the specified index range, and return a collection containing the removed items. Subsequent items are shifted left to fill the resulting gap. If specified, replacement values from an ordered collection will be spliced in place of the removed items.</p><p>To insert <code>replacement</code> before an index <code>n</code> without removing any items, use <code>splice!(collection, n:n-1, replacement)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = [-1, -2, -3, 5, 4, 3, -1]; splice!(A, 4:3, 2)
0-element Array{Int64,1}

julia&gt; A
8-element Array{Int64,1}:
 -1
 -2
 -3
  2
  5
  4
  3
 -1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L1391-L1419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.resize!" href="#Base.resize!"><code>Base.resize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">resize!(a::Vector, n::Integer) -&gt; Vector</code></pre><p>Resize <code>a</code> to contain <code>n</code> elements. If <code>n</code> is smaller than the current collection length, the first <code>n</code> elements will be retained. If <code>n</code> is larger, the new elements are not guaranteed to be initialized.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; resize!([6, 5, 4, 3, 2, 1], 3)
3-element Array{Int64,1}:
 6
 5
 4

julia&gt; a = resize!([6, 5, 4, 3, 2, 1], 8);

julia&gt; length(a)
8

julia&gt; a[1:6]
6-element Array{Int64,1}:
 6
 5
 4
 3
 2
 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L1030-L1059">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.append!" href="#Base.append!"><code>Base.append!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">append!(collection, collection2) -&gt; collection.</code></pre><p>For an ordered container <code>collection</code>, add the elements of <code>collection2</code> to the end of it.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; append!([1],[2,3])
3-element Array{Int64,1}:
 1
 2
 3

julia&gt; append!([1, 2, 3], [4, 5, 6])
6-element Array{Int64,1}:
 1
 2
 3
 4
 5
 6</code></pre><p>Use <a href="collections.html#Base.push!"><code>push!</code></a> to add individual items to <code>collection</code> which are not already themselves in another collection. The result of the preceding example is equivalent to <code>push!([1, 2, 3], 4, 5, 6)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L924-L950">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.prepend!" href="#Base.prepend!"><code>Base.prepend!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prepend!(a::Vector, items) -&gt; collection</code></pre><p>Insert the elements of <code>items</code> to the beginning of <code>a</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; prepend!([3],[1,2])
3-element Array{Int64,1}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/array.jl#L979-L992">source</a></section></article><p>Fully implemented by:</p><ul><li><code>Vector</code> (a.k.a. 1-dimensional <a href="arrays.html#Core.Array"><code>Array</code></a>)</li><li><code>BitVector</code> (a.k.a. 1-dimensional <a href="arrays.html#Base.BitArray"><code>BitArray</code></a>)</li></ul><h2 id="Utility-Collections-1"><a class="docs-heading-anchor" href="#Utility-Collections-1">Utility Collections</a><a class="docs-heading-anchor-permalink" href="#Utility-Collections-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.Pair" href="#Base.Pair"><code>Base.Pair</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pair(x, y)
x =&gt; y</code></pre><p>Construct a <code>Pair</code> object with type <code>Pair{typeof(x), typeof(y)}</code>. The elements are stored in the fields <code>first</code> and <code>second</code>. They can also be accessed via iteration (but a <code>Pair</code> is treated as a single &quot;scalar&quot; for broadcasting operations).</p><p>See also: <a href="collections.html#Base.Dict"><code>Dict</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; p = &quot;foo&quot; =&gt; 7
&quot;foo&quot; =&gt; 7

julia&gt; typeof(p)
Pair{String,Int64}

julia&gt; p.first
&quot;foo&quot;

julia&gt; for x in p
           println(x)
       end
foo
7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/pair.jl#L18-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.Iterators.Pairs" href="#Base.Iterators.Pairs"><code>Base.Iterators.Pairs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Iterators.Pairs(values, keys) &lt;: AbstractDict{eltype(keys), eltype(values)}</code></pre><p>Transforms an indexable container into an Dictionary-view of the same data. Modifying the key-space of the underlying data may invalidate this object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/b8e9a9ecc62ab49003bd4f1834771bdeb8cb1aa2/base/iterators.jl#L160-L165">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="base.html">« Essentials</a><a class="docs-footer-nextpage" href="math.html">Mathematics »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 21 March 2020 14:49">Saturday 21 March 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
